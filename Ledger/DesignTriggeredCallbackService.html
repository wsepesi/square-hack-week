<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=XGMkxXUZTA64h2imyzu79g);.lst-kix_cbca2endi3u5-3>li{counter-increment:lst-ctn-kix_cbca2endi3u5-3}ol.lst-kix_ec3mu9cmun5s-5.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-5 0}ol.lst-kix_cbca2endi3u5-7.start{counter-reset:lst-ctn-kix_cbca2endi3u5-7 0}ol.lst-kix_eex5n9z85ufq-5.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-5 0}ol.lst-kix_1i1s9q527gic-1.start{counter-reset:lst-ctn-kix_1i1s9q527gic-1 0}.lst-kix_cbca2endi3u5-5>li{counter-increment:lst-ctn-kix_cbca2endi3u5-5}.lst-kix_eex5n9z85ufq-4>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-4}ol.lst-kix_cbca2endi3u5-2.start{counter-reset:lst-ctn-kix_cbca2endi3u5-2 0}ol.lst-kix_ec3mu9cmun5s-0.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-0 0}.lst-kix_1i1s9q527gic-5>li{counter-increment:lst-ctn-kix_1i1s9q527gic-5}ol.lst-kix_eex5n9z85ufq-6{list-style-type:none}ol.lst-kix_eex5n9z85ufq-7{list-style-type:none}ol.lst-kix_eex5n9z85ufq-8{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-0{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-1{list-style-type:none}ol.lst-kix_eex5n9z85ufq-0{list-style-type:none}ol.lst-kix_eex5n9z85ufq-1{list-style-type:none}ol.lst-kix_eex5n9z85ufq-2{list-style-type:none}ol.lst-kix_eex5n9z85ufq-3{list-style-type:none}ol.lst-kix_eex5n9z85ufq-4{list-style-type:none}ol.lst-kix_eex5n9z85ufq-5{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-8{list-style-type:none}.lst-kix_eex5n9z85ufq-2>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-2}ol.lst-kix_ec3mu9cmun5s-6{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-7{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-4{list-style-type:none}.lst-kix_eex5n9z85ufq-8>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-8}ol.lst-kix_ec3mu9cmun5s-5{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-2{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-3{list-style-type:none}ol.lst-kix_cbca2endi3u5-0{list-style-type:none}ol.lst-kix_cbca2endi3u5-1{list-style-type:none}ol.lst-kix_eex5n9z85ufq-0.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-0 0}ol.lst-kix_cbca2endi3u5-2{list-style-type:none}ol.lst-kix_cbca2endi3u5-3{list-style-type:none}ol.lst-kix_cbca2endi3u5-4{list-style-type:none}ol.lst-kix_cbca2endi3u5-5{list-style-type:none}ol.lst-kix_cbca2endi3u5-6{list-style-type:none}ol.lst-kix_cbca2endi3u5-7{list-style-type:none}ol.lst-kix_cbca2endi3u5-8{list-style-type:none}.lst-kix_ec3mu9cmun5s-8>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-8}ol.lst-kix_eex5n9z85ufq-6.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-6 0}.lst-kix_2mkif2f02k9l-7>li:before{content:"\0025cb   "}ol.lst-kix_eex5n9z85ufq-1.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-1 0}ol.lst-kix_1i1s9q527gic-2.start{counter-reset:lst-ctn-kix_1i1s9q527gic-2 0}.lst-kix_2mkif2f02k9l-3>li:before{content:"\0025cf   "}.lst-kix_2mkif2f02k9l-1>li:before{content:"\0025cb   "}.lst-kix_ec3mu9cmun5s-5>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-5,lower-roman) ". "}.lst-kix_ec3mu9cmun5s-7>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-7,lower-latin) ". "}.lst-kix_2mkif2f02k9l-5>li:before{content:"\0025a0   "}.lst-kix_1i1s9q527gic-0>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-0,decimal) ". "}.lst-kix_ec3mu9cmun5s-1>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-1}.lst-kix_cbca2endi3u5-2>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-2,lower-roman) ". "}.lst-kix_1i1s9q527gic-3>li{counter-increment:lst-ctn-kix_1i1s9q527gic-3}.lst-kix_ec3mu9cmun5s-3>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-3,decimal) ". "}ol.lst-kix_eex5n9z85ufq-4.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-4 0}.lst-kix_eex5n9z85ufq-1>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-1}ol.lst-kix_cbca2endi3u5-8.start{counter-reset:lst-ctn-kix_cbca2endi3u5-8 0}.lst-kix_cbca2endi3u5-4>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-4,lower-latin) ". "}.lst-kix_9j23me2u28ka-8>li:before{content:"\0025a0   "}.lst-kix_1i1s9q527gic-6>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-6,decimal) ". "}ol.lst-kix_cbca2endi3u5-5.start{counter-reset:lst-ctn-kix_cbca2endi3u5-5 0}.lst-kix_cbca2endi3u5-6>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-6,decimal) ". "}.lst-kix_1i1s9q527gic-2>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-2,lower-roman) ". "}.lst-kix_1i1s9q527gic-4>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-4,lower-latin) ". "}.lst-kix_ec3mu9cmun5s-1>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-1,lower-latin) ". "}.lst-kix_cbca2endi3u5-8>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-8,lower-roman) ". "}ol.lst-kix_1i1s9q527gic-0.start{counter-reset:lst-ctn-kix_1i1s9q527gic-0 0}.lst-kix_eex5n9z85ufq-1>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-1,lower-latin) ". "}ol.lst-kix_eex5n9z85ufq-3.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-3 0}.lst-kix_eex5n9z85ufq-3>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-3,decimal) ". "}.lst-kix_ec3mu9cmun5s-6>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-6}.lst-kix_1i1s9q527gic-8>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-8,lower-roman) ". "}.lst-kix_tjheb4thowdp-3>li:before{content:"\0025cf   "}.lst-kix_eex5n9z85ufq-5>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-5,lower-roman) ". "}.lst-kix_9j23me2u28ka-6>li:before{content:"\0025cf   "}.lst-kix_tjheb4thowdp-5>li:before{content:"\0025a0   "}ol.lst-kix_cbca2endi3u5-6.start{counter-reset:lst-ctn-kix_cbca2endi3u5-6 0}.lst-kix_ec3mu9cmun5s-0>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-0}.lst-kix_eex5n9z85ufq-7>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-7,lower-latin) ". "}.lst-kix_9j23me2u28ka-4>li:before{content:"\0025cb   "}ol.lst-kix_eex5n9z85ufq-2.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-2 0}.lst-kix_9j23me2u28ka-2>li:before{content:"\0025a0   "}.lst-kix_9j23me2u28ka-0>li:before{content:"\0025cf   "}.lst-kix_tjheb4thowdp-1>li:before{content:"\0025cb   "}.lst-kix_eex5n9z85ufq-6>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-6}.lst-kix_1i1s9q527gic-4>li{counter-increment:lst-ctn-kix_1i1s9q527gic-4}.lst-kix_eex5n9z85ufq-0>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-0}.lst-kix_cbca2endi3u5-4>li{counter-increment:lst-ctn-kix_cbca2endi3u5-4}ol.lst-kix_eex5n9z85ufq-8.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-8 0}.lst-kix_1i1s9q527gic-8>li{counter-increment:lst-ctn-kix_1i1s9q527gic-8}ol.lst-kix_cbca2endi3u5-4.start{counter-reset:lst-ctn-kix_cbca2endi3u5-4 0}ol.lst-kix_ec3mu9cmun5s-2.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-2 0}.lst-kix_eex5n9z85ufq-5>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-5}.lst-kix_tjheb4thowdp-7>li:before{content:"\0025cb   "}.lst-kix_tjheb4thowdp-8>li:before{content:"\0025a0   "}.lst-kix_eex5n9z85ufq-7>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-7}.lst-kix_cbca2endi3u5-2>li{counter-increment:lst-ctn-kix_cbca2endi3u5-2}.lst-kix_ec3mu9cmun5s-7>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-7}.lst-kix_1i1s9q527gic-6>li{counter-increment:lst-ctn-kix_1i1s9q527gic-6}.lst-kix_cbca2endi3u5-6>li{counter-increment:lst-ctn-kix_cbca2endi3u5-6}ol.lst-kix_ec3mu9cmun5s-7.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-7 0}.lst-kix_cbca2endi3u5-0>li{counter-increment:lst-ctn-kix_cbca2endi3u5-0}ol.lst-kix_1i1s9q527gic-4.start{counter-reset:lst-ctn-kix_1i1s9q527gic-4 0}.lst-kix_cbca2endi3u5-0>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-0,decimal) ". "}ol.lst-kix_cbca2endi3u5-3.start{counter-reset:lst-ctn-kix_cbca2endi3u5-3 0}ul.lst-kix_tjheb4thowdp-0{list-style-type:none}ul.lst-kix_tjheb4thowdp-1{list-style-type:none}ul.lst-kix_tjheb4thowdp-2{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-8.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-8 0}ul.lst-kix_tjheb4thowdp-3{list-style-type:none}ul.lst-kix_tjheb4thowdp-4{list-style-type:none}ul.lst-kix_tjheb4thowdp-5{list-style-type:none}ul.lst-kix_tjheb4thowdp-6{list-style-type:none}ul.lst-kix_tjheb4thowdp-7{list-style-type:none}ul.lst-kix_tjheb4thowdp-8{list-style-type:none}.lst-kix_ec3mu9cmun5s-5>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-5}ol.lst-kix_ec3mu9cmun5s-1.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-1 0}ol.lst-kix_1i1s9q527gic-3.start{counter-reset:lst-ctn-kix_1i1s9q527gic-3 0}.lst-kix_2mkif2f02k9l-6>li:before{content:"\0025cf   "}.lst-kix_2mkif2f02k9l-4>li:before{content:"\0025cb   "}.lst-kix_2mkif2f02k9l-8>li:before{content:"\0025a0   "}.lst-kix_2mkif2f02k9l-2>li:before{content:"\0025a0   "}.lst-kix_ec3mu9cmun5s-2>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-2}ol.lst-kix_cbca2endi3u5-0.start{counter-reset:lst-ctn-kix_cbca2endi3u5-0 0}.lst-kix_ec3mu9cmun5s-6>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-6,decimal) ". "}.lst-kix_ec3mu9cmun5s-3>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-3}ul.lst-kix_2mkif2f02k9l-8{list-style-type:none}ul.lst-kix_2mkif2f02k9l-6{list-style-type:none}.lst-kix_ec3mu9cmun5s-8>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-8,lower-roman) ". "}ul.lst-kix_2mkif2f02k9l-7{list-style-type:none}.lst-kix_1i1s9q527gic-2>li{counter-increment:lst-ctn-kix_1i1s9q527gic-2}ul.lst-kix_2mkif2f02k9l-4{list-style-type:none}ul.lst-kix_2mkif2f02k9l-5{list-style-type:none}.lst-kix_ec3mu9cmun5s-4>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-4}ul.lst-kix_2mkif2f02k9l-2{list-style-type:none}ul.lst-kix_2mkif2f02k9l-3{list-style-type:none}.lst-kix_cbca2endi3u5-1>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-1,lower-latin) ". "}ol.lst-kix_eex5n9z85ufq-7.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-7 0}ul.lst-kix_2mkif2f02k9l-0{list-style-type:none}.lst-kix_1i1s9q527gic-1>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-1,lower-latin) ". "}ul.lst-kix_2mkif2f02k9l-1{list-style-type:none}.lst-kix_cbca2endi3u5-3>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-3,decimal) ". "}.lst-kix_cbca2endi3u5-5>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-5,lower-roman) ". "}.lst-kix_9j23me2u28ka-7>li:before{content:"\0025cb   "}.lst-kix_cbca2endi3u5-8>li{counter-increment:lst-ctn-kix_cbca2endi3u5-8}.lst-kix_ec3mu9cmun5s-4>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-4,lower-latin) ". "}ol.lst-kix_ec3mu9cmun5s-3.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-3 0}.lst-kix_cbca2endi3u5-7>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-7,lower-latin) ". "}.lst-kix_1i1s9q527gic-5>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-5,lower-roman) ". "}ol.lst-kix_1i1s9q527gic-5.start{counter-reset:lst-ctn-kix_1i1s9q527gic-5 0}.lst-kix_2mkif2f02k9l-0>li:before{content:"\0025cf   "}.lst-kix_ec3mu9cmun5s-2>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-2,lower-roman) ". "}.lst-kix_1i1s9q527gic-0>li{counter-increment:lst-ctn-kix_1i1s9q527gic-0}.lst-kix_1i1s9q527gic-3>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-3,decimal) ". "}ol.lst-kix_1i1s9q527gic-8.start{counter-reset:lst-ctn-kix_1i1s9q527gic-8 0}.lst-kix_ec3mu9cmun5s-0>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-0,decimal) ". "}ol.lst-kix_ec3mu9cmun5s-6.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-6 0}.lst-kix_eex5n9z85ufq-0>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-0,decimal) ". "}ol.lst-kix_1i1s9q527gic-7.start{counter-reset:lst-ctn-kix_1i1s9q527gic-7 0}ul.lst-kix_9j23me2u28ka-8{list-style-type:none}.lst-kix_eex5n9z85ufq-2>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-2,lower-roman) ". "}.lst-kix_eex5n9z85ufq-4>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-4,lower-latin) ". "}ol.lst-kix_1i1s9q527gic-6{list-style-type:none}.lst-kix_1i1s9q527gic-7>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-7,lower-latin) ". "}ol.lst-kix_1i1s9q527gic-7{list-style-type:none}ol.lst-kix_1i1s9q527gic-8{list-style-type:none}.lst-kix_eex5n9z85ufq-6>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-6,decimal) ". "}.lst-kix_eex5n9z85ufq-8>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-8,lower-roman) ". "}.lst-kix_tjheb4thowdp-4>li:before{content:"\0025cb   "}ul.lst-kix_9j23me2u28ka-7{list-style-type:none}ul.lst-kix_9j23me2u28ka-6{list-style-type:none}ol.lst-kix_1i1s9q527gic-0{list-style-type:none}ul.lst-kix_9j23me2u28ka-5{list-style-type:none}ol.lst-kix_1i1s9q527gic-1{list-style-type:none}ul.lst-kix_9j23me2u28ka-4{list-style-type:none}.lst-kix_9j23me2u28ka-5>li:before{content:"\0025a0   "}ol.lst-kix_1i1s9q527gic-2{list-style-type:none}ul.lst-kix_9j23me2u28ka-3{list-style-type:none}ol.lst-kix_1i1s9q527gic-3{list-style-type:none}ul.lst-kix_9j23me2u28ka-2{list-style-type:none}.lst-kix_tjheb4thowdp-6>li:before{content:"\0025cf   "}ol.lst-kix_1i1s9q527gic-4{list-style-type:none}ul.lst-kix_9j23me2u28ka-1{list-style-type:none}ol.lst-kix_1i1s9q527gic-5{list-style-type:none}ul.lst-kix_9j23me2u28ka-0{list-style-type:none}ol.lst-kix_cbca2endi3u5-1.start{counter-reset:lst-ctn-kix_cbca2endi3u5-1 0}.lst-kix_9j23me2u28ka-1>li:before{content:"\0025cb   "}.lst-kix_9j23me2u28ka-3>li:before{content:"\0025cf   "}ol.lst-kix_1i1s9q527gic-6.start{counter-reset:lst-ctn-kix_1i1s9q527gic-6 0}ol.lst-kix_ec3mu9cmun5s-4.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-4 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_tjheb4thowdp-2>li:before{content:"\0025a0   "}.lst-kix_1i1s9q527gic-7>li{counter-increment:lst-ctn-kix_1i1s9q527gic-7}.lst-kix_eex5n9z85ufq-3>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-3}.lst-kix_cbca2endi3u5-1>li{counter-increment:lst-ctn-kix_cbca2endi3u5-1}.lst-kix_1i1s9q527gic-1>li{counter-increment:lst-ctn-kix_1i1s9q527gic-1}.lst-kix_cbca2endi3u5-7>li{counter-increment:lst-ctn-kix_cbca2endi3u5-7}.lst-kix_tjheb4thowdp-0>li:before{content:"\0025cf   "}ol{margin:0;padding:0}table td,table th{padding:0}.c41{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:108.8pt;border-top-color:#000000;border-bottom-style:solid}.c27{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:81.8pt;border-top-color:#000000;border-bottom-style:solid}.c32{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:75pt;border-top-color:#000000;border-bottom-style:solid}.c0{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:51.8pt;border-top-color:#000000;border-bottom-style:solid}.c31{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:113.2pt;border-top-color:#000000;border-bottom-style:solid}.c42{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:115.5pt;border-top-color:#000000;border-bottom-style:solid}.c38{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:428.2pt;border-top-color:#000000;border-bottom-style:solid}.c37{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:99.8pt;border-top-color:#000000;border-bottom-style:solid}.c16{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:422.2pt;border-top-color:#000000;border-bottom-style:solid}.c39{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:110.2pt;border-top-color:#000000;border-bottom-style:solid}.c34{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:445.5pt;border-top-color:#000000;border-bottom-style:solid}.c33{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:144pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:175pt;border-top-color:#000000;border-bottom-style:solid}.c29{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:105pt;border-top-color:#000000;border-bottom-style:solid}.c46{-webkit-text-decoration-skip:none;color:#00796b;font-weight:400;text-decoration:line-through;vertical-align:baseline;text-decoration-skip-ink:none;font-size:11pt;font-family:"Arial";font-style:normal}.c21{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c8{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c25{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c36{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c7{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c5{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c15{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{background-color:#ffffff;padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c13{font-size:10pt;font-family:"Courier New";color:#000080;font-weight:700}.c6{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c28{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c35{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#0000ee;text-decoration:underline}.c40{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c18{font-weight:400;font-size:16pt;font-family:"Arial"}.c26{font-weight:400;font-size:26pt;font-family:"Arial"}.c19{font-weight:400;font-size:11pt;font-family:"Roboto Mono"}.c45{background-color:#ffffff;max-width:720pt;padding:36pt 36pt 36pt 36pt}.c23{font-weight:400;font-size:20pt;font-family:"Arial"}.c3{font-size:10pt;font-family:"Courier New";font-weight:400}.c14{border:1px solid black;margin:5px}.c4{color:inherit;text-decoration:inherit}.c11{margin-left:36pt;padding-left:0pt}.c43{padding:0;margin:0}.c44{height:21pt}.c17{color:#0000ff}.c24{height:0pt}.c22{background-color:#efefef}.c12{height:11pt}.c30{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c45 doc-content"><p class="c8 title" id="h.lctevg2anp9k"><span class="c6 c26">Triggered Publishing Service</span></p><p class="c10"><span>Author: </span><span class="c35"><a class="c4" href="mailto:dskarbek@squareup.com">Daniel Skarbek</a></span></p><p class="c10"><span>Date: </span><span>Jun 1, 2023</span></p><p class="c10"><span class="c1">Status: RFC</span></p><p class="c5"><span class="c1"></span></p><h1 class="c7" id="h.44aylmo4xk5w"><span>Context</span></h1><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><p class="c10"><span>There are several situations where we would want to start a transaction in PaymentBalances and then complete it upon some trigger event. &nbsp;The most common example is captures (Payment event types) that start off as pending money in transactions and then post when the risk clearing event is received. &nbsp;That&rsquo;s a pending transaction that completes on a trigger. &nbsp;The App-Fee Fraud work we did also exposed some similar situations where a transaction might be started, but held awaiting one or more triggers like the unit being unfrozen or a payment hold being lifted. &nbsp;The system we built for this work ended up </span><span class="c40"><a class="c4" href="https://www.google.com/url?q=https://lucid.app/lucidchart/599a927f-6237-4c86-9eda-b7bacde995d0/edit?invitationId%3Dinv_c2755b7d-0ece-4c00-9592-1f66d5da6449%26page%3D0_0%23&amp;sa=D&amp;source=editors&amp;ust=1689358461263705&amp;usg=AOvVaw1RRHbRQYYLmrAu_918O8xF">way too complex</a></span><span>, </span><span>in my opinion</span><span class="c1">. &nbsp;So, I&rsquo;m seeing several cases here that all seem to call for some sort of &ldquo;wait for a trigger and then take the next step&rdquo; capability. &nbsp;I think this could be provided as a primitive, reusable service.</span></p><h1 class="c7" id="h.blsztl7s23lc"><span class="c6 c23">Requirements</span></h1><ul class="c43 lst-kix_9j23me2u28ka-0 start"><li class="c10 c11 li-bullet-0"><span class="c1">Deal with race conditions. &nbsp;If a callback is registered around the same time that the signal it is waiting on is announced, it should be guaranteed that the callback will be triggered, no matter what order those actions show up in the service.</span></li><li class="c10 c11 li-bullet-0"><span class="c1">Handle large degrees of 1:N scaling where 1 signal event triggers N callbacks.</span></li><li class="c10 c11 li-bullet-0"><span class="c1">Guaranteed eventual triggering when signals are met.</span></li><li class="c10 c11 li-bullet-0"><span class="c1">High latency tolerance. &nbsp;Assume that delivering the triggered message in tens of seconds to a couple minutes is acceptable.</span></li><li class="c10 c11 li-bullet-0"><span class="c1">(Nice to have) support time based triggering of callbacks</span></li></ul><h1 class="c7" id="h.ee4dis831ndq"><span class="c6 c23">Proposal</span></h1><p class="c10"><span>Provide a generic service that accepts callback registrations and signal events and when the signals a callback is waiting for have arrived it </span><span>publishes a message to a kafka feed</span><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup><span class="c1">. &nbsp;The callback registration would specify the kafka feed to publish to, and the payload to publish. &nbsp;Probably also optionally support the ability to have the published call-back include the signals received.</span></p><ul class="c43 lst-kix_tjheb4thowdp-0 start"><li class="c10 c11 li-bullet-0"><span class="c30">Callback</span><span class="c1">: a payload to be published when triggered and the topic to publish it to.</span></li><li class="c10 c11 li-bullet-0"><span class="c30">Signal</span><span>: A type, key, and value. &nbsp;The type and key form a unique key. &nbsp;The same type and key being announced with a different value will overwrite the prior value if we are still holding it. The other way to think of this is that a</span><span>&nbsp;type and key being reused</span><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup><span class="c1">&nbsp;causes all prior instances of that signal to be immediately flushed from the system, because signals are only kept for a short time in the system before being flushed.</span></li><li class="c10 c11 li-bullet-0"><span class="c30">Trigger</span><span class="c1">: a callback is created with a trigger condition (or set of conditions) which determine when the callback payload is published. Triggers would be like a boolean expression watching for certain signals to be in certain states, at which point the effect is triggered.</span></li></ul><h3 class="c25" id="h.6wcpjgs73stc"><span class="c15">Signal Events</span></h3><p class="c10"><span class="c1">It&rsquo;s expected that a client using the service to register callbacks is also sending signal events that its triggers might be watching for.</span></p><a id="t.7183ab1dd791db3b32cc732768df595894eac1e0"></a><a id="t.0"></a><table class="c28"><tr class="c24"><td class="c38" colspan="1" rowspan="1"><p class="c2"><span class="c13">message </span><span class="c3">Signal</span><span class="c6 c3">&nbsp;{</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">enum </span><span class="c6 c3">Type {</span></p><p class="c2"><span class="c6 c3">&nbsp; &nbsp;RISK_PAYMENT_CLEARING,</span></p><p class="c2"><span class="c3 c6">&nbsp; &nbsp;PAYMENT_HOLD,</span></p><p class="c2"><span class="c6 c3">&nbsp; &nbsp;SELLER_FREEZE</span></p><p class="c2"><span class="c6 c3">&nbsp;}</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">required Type </span><span class="c3">type = </span><span class="c3 c17">1</span><span class="c6 c3">;</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">required string </span><span class="c3">key = </span><span class="c3 c17">2</span><span class="c6 c3">;</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">optional string </span><span class="c3">value = </span><span class="c3 c17">3</span><span class="c3">;</span></p><p class="c2"><span class="c3">}</span></p></td></tr></table><p class="c10"><span class="c1">Potentially, the signal service could have even the type be an opaque string and leave all definition to the clients. &nbsp;But, these are the values that we would use for our initial use case. </span></p><a id="t.93f97e2d92321aad3ef4c4511f57b0a511e9c130"></a><a id="t.1"></a><table class="c28"><tr class="c24"><td class="c20 c22" colspan="1" rowspan="1"><p class="c9"><span class="c1">Type</span></p></td><td class="c20 c22" colspan="1" rowspan="1"><p class="c9"><span class="c1">Key</span></p></td><td class="c20 c22" colspan="1" rowspan="1"><p class="c9"><span class="c1">Value</span></p></td></tr><tr class="c24"><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">RISK_PAYMENT_STATUS</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">Payment Token</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">Status &ndash; typically AUTOMATICALLY_REVIEWED</span></p></td></tr><tr class="c24"><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">PAYMENT_HOLD</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">Payment Token</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">Held / Released</span></p></td></tr><tr class="c24"><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">SELLER_FREEZE</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">Unit Token</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c9"><span class="c1">FROZEN / UNFROZEN</span></p></td></tr></table><h3 class="c25" id="h.ctr27wiqult1"><span>Callbacks with Triggers</span></h3><p class="c10"><span>When a new callback is being registered it will have a set of triggers &ndash; basically signal states to watch for. &nbsp;The next question is if multiple triggers are an &ldquo;and&rdquo; condition or an &ldquo;or&rdquo; condition. &nbsp;The basic functionality we need for the existing use-cases is &ldquo;and&rdquo;; the callback should fire when all triggers are met. &nbsp;But, we could build in some more flexibility by supporting an </span><span>or-list of and-lists</span><span class="c1">&nbsp;of triggers. &nbsp;</span></p><a id="t.49fc7381ed492a99f746a5a841c0437b54fe9244"></a><a id="t.2"></a><table class="c28"><tr class="c24"><td class="c16" colspan="1" rowspan="1"><p class="c2"><span class="c13">message </span><span class="c6 c3">Trigger {</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">repeated </span><span class="c3">Signal signal_watch = </span><span class="c3 c17">1</span><span class="c6 c3">;</span></p><p class="c2"><span class="c6 c3">}</span></p><p class="c2 c12"><span class="c6 c3"></span></p><p class="c2"><span class="c13">message </span><span class="c3">CallbackRequest</span><span class="c6 c3">&nbsp;{</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">required string </span><span class="c3">target_kafka_target</span><span class="c3">&nbsp;= </span><span class="c3 c17">1</span><span class="c6 c3">;</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">required Any </span><span class="c3">payload</span><span class="c3">&nbsp;= </span><span class="c3 c17">2</span><span class="c3">;</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">required string </span><span class="c3">idempotency_key</span><span class="c3">&nbsp;= </span><span class="c3 c17">3</span><span class="c3">;</span></p><p class="c2"><span class="c3">&nbsp;</span><span class="c13">repeated Trigger </span><span class="c3">trigger</span><span class="c3">&nbsp;= </span><span class="c3 c17">4</span><span class="c3">;</span></p><p class="c2"><span class="c6 c3">}</span></p></td></tr></table><p class="c10"><span class="c1">The Trigger is a list of signal states to watch for where the trigger is considered &ldquo;tripped&rdquo; once all of the signals are found. &nbsp;The trigger in the CallbackRequest is a repeating element, allowing you to specify multiple different triggers, any one of which will trigger the callback to be published. &nbsp;Hence, this is our &ldquo;or-list of and-lists.&rdquo;</span></p><h1 class="c7" id="h.ukqu0b53aiwr"><span class="c6 c23">Architecture</span></h1><h3 class="c36" id="h.6q5fmmiecg0e"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 837.39px; height: 324.58px;"><img alt="" src="images/image1.png" style="width: 837.39px; height: 324.58px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><p class="c10"><span>Both the Callback Registration and Signal Event RPCs just write their payload to DynamoDB and return successfully. &nbsp;All actual processing of them happens in an async processor that is triggered by </span><span>DynamoDB Streams</span><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup><span class="c1">&nbsp;that detect the entries being written. &nbsp;I&rsquo;ve pictured this as independent lambdas, because that also helps show the logic, but of course, this could all be one app doing the processing of these three stream event types. &nbsp;The processing of new signals is to update callbacks that are watching for them. &nbsp;When a new callback shows up, we look for any signals that already exist in our store and do the update that signal should have done if it showed up after the callback. &nbsp;The handling of signal watch updates is the key functionality that detects when a trigger is satisfied and publishes the callback payload and deletes the callback from the store. &nbsp;Doing all of this logic strictly in async processing downstream of the data store accomplishes multiple things. &nbsp;It isolates failure domains. &nbsp;It allows for dealing with unbounded numbers of actions that need to happen as a result of a single signal update. &nbsp;It also forms the basis of resolving Callback/Signal races.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">Because the stores are written to before the event about that data is fired and responded to, there is a serialization that happens. &nbsp;It isn&rsquo;t possible that both a callback and signal come in and look for each other and neither sees the other. &nbsp;Because the looking (in the lambda) happens strictly after the store is updated, so if it doesn&rsquo;t see something, that other thing must not have been stored yet, which means it can not have streamed to its own lambda yet, which means when it does, the first thing is guaranteed to be there. &nbsp;So, no matter how a callback registration and a signal race with each other, the trigger will get evaluated when the second one arrives and it will see the first one. &nbsp;The one caveat there is this is only meant to deal with race conditions where the client that is registering the callback has determined that it needs to wait for the signal. &nbsp;Meaning if we are waiting for a seller to be unfrozen, but they were unfrozen weeks ago then we aren&rsquo;t going to see that. &nbsp;We only store signals for a short time to cover race conditions. &nbsp;Registering a signal watch indicates that the state seen by the client is that the signal is not met yet. &nbsp;There can be a race there, between the client checking some state and a signal being published about that state, and we will cover that race condition. &nbsp;But, we are not maintaining a permanent store of historic signals to reference.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">Finally, note that it is possible that one signal is watched by multiple triggers. &nbsp;In fact potentially watched by an extremely large number of triggers. &nbsp;Imagine a high volume seller, doing millions of transactions, that happens to be frozen. &nbsp;Then they get unfrozen. &nbsp;That one signal could trigger millions of transactions to complete. &nbsp;So, we can&rsquo;t assume that the signal insert lambda can successfully process everything in a single process. &nbsp;It needs to be capable of batching the work. &nbsp;Fortunately, the fact that it&rsquo;s working off of a stream event makes this easier. &nbsp;The lambda will search for triggers that possibly match the signal, up to some limit, process them, and then attempt to repeat. &nbsp;If the process dies or errors, then the event is not marked complete and will be retried. &nbsp;When it is retried, some of the triggers have already been processed and so the job has made some progress and resumes. &nbsp;</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">The query should be batched by timestamp or id or something that sequences the items so that we can work through the results &ndash; much like we would do on a list end-point that has to return a cursor for subsequent fetches. &nbsp;We can use this in the process that is working through the batch. &nbsp;If the process dies or errors and has to restart, it will have to start over with the evaluation, but that should be more rare. &nbsp;In general, a process will eventually succeed in scanning all the items of the batch.</span></p><p class="c5"><span class="c46"></span></p><p class="c10"><span>Our signal store needs to be</span><span class="c1">&nbsp;durable but temporary. &nbsp;We are not the SOR for this data, so we don&rsquo;t need to store it permanently, but this is also more durable than a cache. &nbsp;We have no fall-back system to read from, so while we are holding the data we need to hold it accurately and reliably. &nbsp;We need a queryable data store for the signals because we have to deal with race conditions. &nbsp;If it weren&rsquo;t for that, then the signals could just go in a queue and get processed and discarded. &nbsp;But, because we need to be able to query for recently arrived signals when a callback is registered, we need a queryable data store and need it to be durable, even though we mostly just want a feed of signals.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">Note that there is some risk of double publishing. &nbsp;The callback update lambda might fail and restart or something, or need to handle the same update event more than once for some reason. &nbsp;But, this is nothing new. &nbsp;Kafka in itself can double deliver payloads, so clients need to idempotently handle messages.</span></p><h1 class="c7" id="h.wpwqh014dcjj"><span class="c6 c23">Implementation</span></h1><h2 class="c21" id="h.z69wsbvjpkjq"><span class="c6 c18">Expiring Signals</span></h2><p class="c10"><span>The most interesting detail we&rsquo;ve glossed over thus far is how the signals get deleted. &nbsp;We said we only want to keep them for a day or so, and we will accomplish that with a TTL on the record, which is </span><span>a feature provided by DynamoDB</span><sup><a href="#cmnt8" id="cmnt_ref8">[h]</a></sup><sup><a href="#cmnt9" id="cmnt_ref9">[i]</a></sup><span class="c1">. &nbsp;The one challenge of this is that this means that a callback that is waiting for signals A, B, and C, when B is received must be updated to know that it no longer needs to wait for B. &nbsp;Because it might wait for a very long time for A and C to show up. &nbsp;By that time, B will have expired out of the store. &nbsp;So, the lambda can&rsquo;t just check all the signals expecting to still see B in the store when A and C have shown up.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">Alternatively, we could say that signals stay around as long as they have callback triggers that are watching them, but that would require building some custom flushing logic. &nbsp;Still it is a viable option and has the upside of not requiring any modification of the callback objects. &nbsp;But, I think just designing around using the TTL is simpler.</span></p><h2 class="c21" id="h.isgoywf6qwog"><span class="c6 c18">Dynamo Model</span></h2><p class="c10"><span class="c1">The model needs to store signals and callbacks in a way where each callback has a set of signal watch sets where in each set signals can get marked as fulfilled and we can efficiently search for sets by unfulfilled signal.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">I&rsquo;m definitely not an expert Dynamo modeler, so definitely open to adjustments here.</span></p><h3 class="c25" id="h.6628xbjeqqlp"><span class="c15">Signal Table</span></h3><a id="t.d6295546239aebf66d69d419285b36b47d8273c4"></a><a id="t.3"></a><table class="c28"><tr class="c24"><td class="c41" colspan="1" rowspan="1"><p class="c9"><span class="c1">Partition Key</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c9"><span>Sort Key</span><sup><a href="#cmnt10" id="cmnt_ref10">[j]</a></sup><sup><a href="#cmnt11" id="cmnt_ref11">[k]</a></sup><sup><a href="#cmnt12" id="cmnt_ref12">[l]</a></sup></p></td><td class="c42" colspan="1" rowspan="1"><p class="c9"><span class="c1">Attributes</span></p></td><td class="c31" colspan="1" rowspan="1"><p class="c9"><span class="c1">TTL</span></p></td></tr><tr class="c24"><td class="c41" colspan="1" rowspan="1"><p class="c9"><span class="c1">Type::Key</span></p></td><td class="c37" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ldquo;Signal&rdquo;</span></p></td><td class="c42" colspan="1" rowspan="1"><p class="c9"><span class="c1">Value</span></p></td><td class="c31" colspan="1" rowspan="1"><p class="c9"><span class="c1">Last update + 1 day</span></p></td></tr></table><p class="c10"><span class="c1">There are no secondary keys. &nbsp;All lookups are by single type and key. &nbsp;Each row will have a TTL that is updated on each update to 1 day in the future. &nbsp;Inserts are by type and key and overwrite any existing value if the row already exists.</span></p><h3 class="c25" id="h.12eyct3thllt"><span class="c15">Callback Table</span></h3><a id="t.72c34467c2128b6351ed548e12b6d05b11350b66"></a><a id="t.4"></a><table class="c28"><tr class="c44"><td class="c27" colspan="1" rowspan="1"><p class="c9"><span class="c1">Partition Key</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c9"><span class="c1">Sort Key</span></p></td><td class="c34" colspan="6" rowspan="1"><p class="c9"><span class="c1">Attributes</span></p></td></tr><tr class="c24"><td class="c27" colspan="1" rowspan="1"><p class="c9"><span class="c1">Callback ID</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c9"><span class="c1">&ldquo;Payload&rdquo;</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c9"><span class="c1">target_kafka_topic</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c9"><span class="c1">payload_encoded</span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c9 c12"><span class="c1"></span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c9 c12"><span class="c1"></span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c9 c12"><span class="c1"></span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c9 c12"><span class="c1"></span></p></td></tr><tr class="c24"><td class="c27" colspan="1" rowspan="1"><p class="c9"><span class="c1">Callback ID</span></p></td><td class="c33" colspan="1" rowspan="1"><p class="c9"><span class="c1">Trigger index : signal index</span></p></td><td class="c39" colspan="1" rowspan="1"><p class="c9"><span class="c1">signal_type</span></p></td><td class="c29" colspan="1" rowspan="1"><p class="c9"><span class="c1">signal_name</span></p></td><td class="c32" colspan="1" rowspan="1"><p class="c9"><span class="c1">signal_value</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c9"><span class="c1">status</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c9"><span class="c1">gsi_pk</span></p></td><td class="c0" colspan="1" rowspan="1"><p class="c9"><span class="c1">gsi_sk</span></p></td></tr></table><p class="c10"><span class="c1">When creating a callback, a callback ID is created by combining the target_kafka_topic and the idempotency_key and along with the callback payload is stored as the first row above &ndash; the primary entity row. &nbsp;Each trigger and signal watch on the callback will create another row under the callback. &nbsp;The &ldquo;trigger index&rdquo; and &ldquo;signal index&rdquo; can just be the zero-based index values of the trigger array and the signal_watch array inside it. &nbsp;Each signal watch has a status as to whether it has been met yet. &nbsp;If a signal is not met then it has a non-null gsi_pk and gsi_sk attribute which is set with the signal type and name as the gsi_pk, and the signal value as the gsi_sk. &nbsp;These attributes are then used in the construction of a GSI &ndash; as inferred by their name. &nbsp;So, when a signal is updated, the handler of that change does a search by the GSI for all signal watches that need updating. &nbsp;It can then update the status and remove the gsi attributes to remove it from the GSI since it is now met. &nbsp;Then we can load the other rows for the callback and see if a complete trigger is now satisfied and if so publish the callback message and delete the rows.</span></p><h2 class="c21" id="h.dd9blwow9r6c"><span class="c6 c18">Extensions to the Model</span></h2><h3 class="c25" id="h.wherknr6g4hk"><span class="c15">Flapping Signals</span></h3><p class="c10"><span class="c1">The model as described above fits the basic use case of watching for each signal and once you&rsquo;ve seen them all publishing the callback. &nbsp;But, what if one of those signals is waiting for the seller to be unfrozen and that happens, but some other signal is still being waited on and by the time it comes along the seller has been frozen again? &nbsp;This can still work because the callback code should re-check these requirements and re-register a callback if there is some state it still needs to wait on. &nbsp;In fact, even if we do the below idea, we may still need to do this because there might be a race condition (or we might decide we need to care about that race condition). &nbsp;But, there are some simple changes we could make to minimize the chance of a callback like this that results in needing to re-register a callback on some other condition.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">We could tweak the basic model to be that we register signal states we are watching for and we trigger the callback when all signals are in those states. &nbsp;What that means is that once a signal is met, we don&rsquo;t remove it from the GSI, and we do GSI lookups on just the type and name. &nbsp;If the watch is watching for the current value, then we mark the signal satisfied, if it does not match, then we mark the signal not satisfied. &nbsp;On each update we check to see if a trigger is fully satisfied or not. &nbsp;In this way, we could be watching seller freeze status and see it clear and then freeze again and we would know that we needed to wait to see it clear again. &nbsp;Then, when we get the callback, we know that the latest state of the signals is that they all match what we were watching for.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">The other tweak we should add if we do this is the ability to specify a signal watch that is satisfied as of the time of creation. &nbsp;For example you see that the seller is not frozen, but in your callback registry, you want to specify that they should not become frozen, so you specify a signal watch on the seller being unfrozen and mark that it is currently satisfied. &nbsp;Then if they get frozen, the signal system will mark that watch no longer satisfied and it will wait until they are unfrozen again.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">In that case, maybe we don&rsquo;t need to re-check the signal state. &nbsp;There&rsquo;s a chance that we trigger a callback and then right after that a signal update comes in that invalidates the trigger (like the seller just gets frozen). &nbsp;That means that by the time we consume the callback, the state of the signal is no longer what we need, but it *just* was. &nbsp;So, maybe we say that we will pretend we are handling the callback as of the time and state it was triggered and that&rsquo;s ok, or maybe we still re-check the state to catch this race condition.</span></p><h3 class="c25" id="h.ewwwqgppruyw"><span class="c15">Knowing what trigger fired for you</span></h3><p class="c10"><span class="c1">Because we support having multiple different triggers that could fire your callback (the or-list of triggers), you might want to know which trigger conditions resulted in the callback. &nbsp;I want to be able to have the callback payload be the actual payload published to Kafka so that this system can be used for delayed publishing of &ldquo;public&rdquo; payloads that are meant for consumption by clients besides a specific callback client that is expecting a callback envelope. &nbsp;But, we could support an option on registration that causes the callback payload to be published inside of a callback envelope that includes triggering information.</span></p><h3 class="c25" id="h.rs5che2vvz"><span class="c15">Time Based Signals</span></h3><p class="c10"><span class="c1">Our current use-cases don&rsquo;t specifically need a time based trigger, but it is easy to imagine several situations where it would be useful. &nbsp;So, how can we have a signal that is watching for a time? &nbsp;The tricky part here is that the clock is essentially one signal and a very large number of triggers might be watching it. &nbsp;Also, the values of this signal are very fine-grained. &nbsp;Time comparisons typically need a &ldquo;less than&rdquo; or &ldquo;greater than&rdquo; comparison, not an &ldquo;equal to.&rdquo; &nbsp;So, I think we would need to have a special, server defined signal type for time, and we&rsquo;d have a cron job style process inside the signal that pings updates to this signal on a regular basis. &nbsp;Probably not any more frequently than 15mins, and maybe just hourly, this job could run and do a signal update where it looks for time watches and does a less than comparison on the value. &nbsp;So, clients could set the time type and set the value to the unix timestamp after which the signal should be considered triggered. &nbsp;Probably we&rsquo;d have a special type and the name would probably be blank, or maybe the name could indicate whether it wanted to do &ldquo;less than&rdquo; or &ldquo;greater than&rdquo; comparison and there would be two processes for those.</span></p><p class="c5"><span class="c1"></span></p><p class="c10"><span class="c1">Probably this signal we would want to remove from the GSI once satisfied because we know it will stay satisfied and we don&rsquo;t want to clutter the index with a bunch of satisfied signals. &nbsp;And, perhaps that should be a general capability that clients can specify also. &nbsp;Perhaps for any signal, clients should indicate whether the signal should be assumed to be permanently cleared once it is cleared once. &nbsp;For example risk payment clearing signals would work like that also. &nbsp;This could be done by an option on the signal RPC to assume the</span></p><p class="c10"><span class="c1">Signal state is permanent. &nbsp;On that option we would remove matching signal watches from the GSI. &nbsp;And, we would probably store a &ldquo;permanent&rdquo; marker in the signal store so that we can raise an alarm if an update does show up for it.</span></p><div class="c14"><p class="c9"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c1">Is this service specifically for production use? Or could we make it generic enough to trigger other things, like simulating time-based bank account things?</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c1">As proposed it&#39;s pretty generic.&nbsp; Intention would be to be open to multiple other use-cases.</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c1">&#x1f60e;&nbsp; this is a pretty cool concept. any of our services that use kafka feeds can basically plug into this.</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c1">What sort of examples of a key being reused are there? Do we anticipate this being common, or rare but possible?</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c1">Like &quot;seller XYZ freeze status&quot; would be a type and key combo and it would have values like &quot;frozen&quot; and &quot;unfrozen&quot;.&nbsp; As those events happen, there will be signals about them and those re-use the type/key, thus the value of the signal is updated rather than it being a separate signal.</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c1">Do we have any current examples of teams using ddb streams? I don&#39;t know if I&#39;m remembering correctly, but I thought ddb streams had some capacity issues. What sort of load would we expect on this table?</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c1">We do and we&#39;d have to investigate the details.&nbsp; I think there are some throughput limits, but I think our latency tolerance would allow us to use it.&nbsp; It&#39;s certainly the easiest&nbsp; approach.</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref8" id="cmnt8">[h]</a><span class="c1">We should make sure we still put our own TTL logic in.</span></p><p class="c9"><span class="c1">&quot;Important</span></p><p class="c9"><span class="c1">TTL typically deletes expired items within a few days. Depending on the size and activity level of a table, the actual delete operation of an expired item can vary. Because TTL is meant to be a background process, the nature of the capacity used to expire and delete items via TTL is variable (but free of charge).</span></p><p class="c9 c12"><span class="c1"></span></p><p class="c9"><span class="c1">Items that have expired, but haven&rsquo;t yet been deleted by TTL, still appear in reads, queries, and scans. If you do not want expired items in the result set, you must filter them out. To do this, use a filter expression that returns only items where the Time to Live expiration value is greater than the current time in epoch format. For more information, see Filter expressions for scan.</span></p><p class="c9 c12"><span class="c1"></span></p><p class="c9"><span class="c1">Items that are past their expiration, but have not yet been deleted can still be updated, and successful updates to change or remove the expiration attribute will be honored.&quot;</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref9" id="cmnt9">[i]</a><span class="c1">This is all fine with me.&nbsp; I just don&#39;t want to have a contract that we store signals forever.&nbsp; As long as we can say that signals eventually get deleted sometime after 1 day (or whatever we pick), then that&#39;s fine with me.</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref10" id="cmnt10">[j]</a><span class="c1">Or, can we just omit this when the primary key is already unique?</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref11" id="cmnt11">[k]</a><span class="c1">usually when partition key is unique, we add a static sort key like &quot;signal&quot;</span></p></div><div class="c14"><p class="c9"><a href="#cmnt_ref12" id="cmnt12">[l]</a><span class="c1">Hmm, or should we have one of type or key be the sort key?&nbsp; Maybe key is the partition key and type is the sort key?</span></p></div></body></html>
