<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=XGMkxXUZTA64h2imyzu79g);.lst-kix_cbca2endi3u5-3>li{counter-increment:lst-ctn-kix_cbca2endi3u5-3}ol.lst-kix_ec3mu9cmun5s-5.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-5 0}ol.lst-kix_cbca2endi3u5-7.start{counter-reset:lst-ctn-kix_cbca2endi3u5-7 0}ol.lst-kix_eex5n9z85ufq-5.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-5 0}ol.lst-kix_1i1s9q527gic-1.start{counter-reset:lst-ctn-kix_1i1s9q527gic-1 0}.lst-kix_cbca2endi3u5-5>li{counter-increment:lst-ctn-kix_cbca2endi3u5-5}.lst-kix_eex5n9z85ufq-4>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-4}ol.lst-kix_cbca2endi3u5-2.start{counter-reset:lst-ctn-kix_cbca2endi3u5-2 0}ol.lst-kix_ec3mu9cmun5s-0.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-0 0}.lst-kix_1i1s9q527gic-5>li{counter-increment:lst-ctn-kix_1i1s9q527gic-5}ol.lst-kix_eex5n9z85ufq-6{list-style-type:none}ol.lst-kix_eex5n9z85ufq-7{list-style-type:none}ol.lst-kix_eex5n9z85ufq-8{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-0{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-1{list-style-type:none}ol.lst-kix_eex5n9z85ufq-0{list-style-type:none}ol.lst-kix_eex5n9z85ufq-1{list-style-type:none}ol.lst-kix_eex5n9z85ufq-2{list-style-type:none}ol.lst-kix_eex5n9z85ufq-3{list-style-type:none}ol.lst-kix_eex5n9z85ufq-4{list-style-type:none}ol.lst-kix_eex5n9z85ufq-5{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-8{list-style-type:none}.lst-kix_eex5n9z85ufq-2>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-2}ol.lst-kix_ec3mu9cmun5s-6{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-7{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-4{list-style-type:none}.lst-kix_eex5n9z85ufq-8>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-8}ol.lst-kix_ec3mu9cmun5s-5{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-2{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-3{list-style-type:none}ol.lst-kix_cbca2endi3u5-0{list-style-type:none}ol.lst-kix_cbca2endi3u5-1{list-style-type:none}ol.lst-kix_eex5n9z85ufq-0.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-0 0}ol.lst-kix_cbca2endi3u5-2{list-style-type:none}ol.lst-kix_cbca2endi3u5-3{list-style-type:none}ol.lst-kix_cbca2endi3u5-4{list-style-type:none}ol.lst-kix_cbca2endi3u5-5{list-style-type:none}ol.lst-kix_cbca2endi3u5-6{list-style-type:none}ol.lst-kix_cbca2endi3u5-7{list-style-type:none}ol.lst-kix_cbca2endi3u5-8{list-style-type:none}.lst-kix_ec3mu9cmun5s-8>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-8}ol.lst-kix_eex5n9z85ufq-6.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-6 0}.lst-kix_2mkif2f02k9l-7>li:before{content:"\0025cb   "}ol.lst-kix_eex5n9z85ufq-1.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-1 0}ol.lst-kix_1i1s9q527gic-2.start{counter-reset:lst-ctn-kix_1i1s9q527gic-2 0}.lst-kix_2mkif2f02k9l-3>li:before{content:"\0025cf   "}.lst-kix_2mkif2f02k9l-1>li:before{content:"\0025cb   "}.lst-kix_ec3mu9cmun5s-5>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-5,lower-roman) ". "}.lst-kix_ec3mu9cmun5s-7>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-7,lower-latin) ". "}.lst-kix_2mkif2f02k9l-5>li:before{content:"\0025a0   "}.lst-kix_1i1s9q527gic-0>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-0,decimal) ". "}.lst-kix_ec3mu9cmun5s-1>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-1}.lst-kix_cbca2endi3u5-2>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-2,lower-roman) ". "}.lst-kix_1i1s9q527gic-3>li{counter-increment:lst-ctn-kix_1i1s9q527gic-3}.lst-kix_ec3mu9cmun5s-3>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-3,decimal) ". "}ol.lst-kix_eex5n9z85ufq-4.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-4 0}.lst-kix_eex5n9z85ufq-1>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-1}ol.lst-kix_cbca2endi3u5-8.start{counter-reset:lst-ctn-kix_cbca2endi3u5-8 0}.lst-kix_cbca2endi3u5-4>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-4,lower-latin) ". "}.lst-kix_9j23me2u28ka-8>li:before{content:"\0025a0   "}.lst-kix_1i1s9q527gic-6>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-6,decimal) ". "}ol.lst-kix_cbca2endi3u5-5.start{counter-reset:lst-ctn-kix_cbca2endi3u5-5 0}.lst-kix_cbca2endi3u5-6>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-6,decimal) ". "}.lst-kix_1i1s9q527gic-2>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-2,lower-roman) ". "}.lst-kix_1i1s9q527gic-4>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-4,lower-latin) ". "}.lst-kix_ec3mu9cmun5s-1>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-1,lower-latin) ". "}.lst-kix_cbca2endi3u5-8>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-8,lower-roman) ". "}ol.lst-kix_1i1s9q527gic-0.start{counter-reset:lst-ctn-kix_1i1s9q527gic-0 0}.lst-kix_eex5n9z85ufq-1>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-1,lower-latin) ". "}ol.lst-kix_eex5n9z85ufq-3.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-3 0}.lst-kix_eex5n9z85ufq-3>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-3,decimal) ". "}.lst-kix_ec3mu9cmun5s-6>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-6}.lst-kix_1i1s9q527gic-8>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-8,lower-roman) ". "}.lst-kix_tjheb4thowdp-3>li:before{content:"\0025cf   "}.lst-kix_eex5n9z85ufq-5>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-5,lower-roman) ". "}.lst-kix_9j23me2u28ka-6>li:before{content:"\0025cf   "}.lst-kix_tjheb4thowdp-5>li:before{content:"\0025a0   "}ol.lst-kix_cbca2endi3u5-6.start{counter-reset:lst-ctn-kix_cbca2endi3u5-6 0}.lst-kix_ec3mu9cmun5s-0>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-0}.lst-kix_eex5n9z85ufq-7>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-7,lower-latin) ". "}.lst-kix_9j23me2u28ka-4>li:before{content:"\0025cb   "}ol.lst-kix_eex5n9z85ufq-2.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-2 0}.lst-kix_9j23me2u28ka-2>li:before{content:"\0025a0   "}.lst-kix_9j23me2u28ka-0>li:before{content:"\0025cf   "}.lst-kix_tjheb4thowdp-1>li:before{content:"\0025cb   "}.lst-kix_eex5n9z85ufq-6>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-6}.lst-kix_1i1s9q527gic-4>li{counter-increment:lst-ctn-kix_1i1s9q527gic-4}.lst-kix_eex5n9z85ufq-0>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-0}.lst-kix_cbca2endi3u5-4>li{counter-increment:lst-ctn-kix_cbca2endi3u5-4}ol.lst-kix_eex5n9z85ufq-8.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-8 0}.lst-kix_1i1s9q527gic-8>li{counter-increment:lst-ctn-kix_1i1s9q527gic-8}ol.lst-kix_cbca2endi3u5-4.start{counter-reset:lst-ctn-kix_cbca2endi3u5-4 0}ol.lst-kix_ec3mu9cmun5s-2.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-2 0}.lst-kix_eex5n9z85ufq-5>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-5}.lst-kix_tjheb4thowdp-7>li:before{content:"\0025cb   "}.lst-kix_tjheb4thowdp-8>li:before{content:"\0025a0   "}.lst-kix_eex5n9z85ufq-7>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-7}.lst-kix_cbca2endi3u5-2>li{counter-increment:lst-ctn-kix_cbca2endi3u5-2}.lst-kix_ec3mu9cmun5s-7>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-7}.lst-kix_1i1s9q527gic-6>li{counter-increment:lst-ctn-kix_1i1s9q527gic-6}.lst-kix_cbca2endi3u5-6>li{counter-increment:lst-ctn-kix_cbca2endi3u5-6}ol.lst-kix_ec3mu9cmun5s-7.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-7 0}.lst-kix_cbca2endi3u5-0>li{counter-increment:lst-ctn-kix_cbca2endi3u5-0}ol.lst-kix_1i1s9q527gic-4.start{counter-reset:lst-ctn-kix_1i1s9q527gic-4 0}.lst-kix_cbca2endi3u5-0>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-0,decimal) ". "}ol.lst-kix_cbca2endi3u5-3.start{counter-reset:lst-ctn-kix_cbca2endi3u5-3 0}ul.lst-kix_tjheb4thowdp-0{list-style-type:none}ul.lst-kix_tjheb4thowdp-1{list-style-type:none}ul.lst-kix_tjheb4thowdp-2{list-style-type:none}ol.lst-kix_ec3mu9cmun5s-8.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-8 0}ul.lst-kix_tjheb4thowdp-3{list-style-type:none}ul.lst-kix_tjheb4thowdp-4{list-style-type:none}ul.lst-kix_tjheb4thowdp-5{list-style-type:none}ul.lst-kix_tjheb4thowdp-6{list-style-type:none}ul.lst-kix_tjheb4thowdp-7{list-style-type:none}ul.lst-kix_tjheb4thowdp-8{list-style-type:none}.lst-kix_ec3mu9cmun5s-5>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-5}ol.lst-kix_ec3mu9cmun5s-1.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-1 0}ol.lst-kix_1i1s9q527gic-3.start{counter-reset:lst-ctn-kix_1i1s9q527gic-3 0}.lst-kix_2mkif2f02k9l-6>li:before{content:"\0025cf   "}.lst-kix_2mkif2f02k9l-4>li:before{content:"\0025cb   "}.lst-kix_2mkif2f02k9l-8>li:before{content:"\0025a0   "}.lst-kix_2mkif2f02k9l-2>li:before{content:"\0025a0   "}.lst-kix_ec3mu9cmun5s-2>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-2}ol.lst-kix_cbca2endi3u5-0.start{counter-reset:lst-ctn-kix_cbca2endi3u5-0 0}.lst-kix_ec3mu9cmun5s-6>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-6,decimal) ". "}.lst-kix_ec3mu9cmun5s-3>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-3}ul.lst-kix_2mkif2f02k9l-8{list-style-type:none}ul.lst-kix_2mkif2f02k9l-6{list-style-type:none}.lst-kix_ec3mu9cmun5s-8>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-8,lower-roman) ". "}ul.lst-kix_2mkif2f02k9l-7{list-style-type:none}.lst-kix_1i1s9q527gic-2>li{counter-increment:lst-ctn-kix_1i1s9q527gic-2}ul.lst-kix_2mkif2f02k9l-4{list-style-type:none}ul.lst-kix_2mkif2f02k9l-5{list-style-type:none}.lst-kix_ec3mu9cmun5s-4>li{counter-increment:lst-ctn-kix_ec3mu9cmun5s-4}ul.lst-kix_2mkif2f02k9l-2{list-style-type:none}ul.lst-kix_2mkif2f02k9l-3{list-style-type:none}.lst-kix_cbca2endi3u5-1>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-1,lower-latin) ". "}ol.lst-kix_eex5n9z85ufq-7.start{counter-reset:lst-ctn-kix_eex5n9z85ufq-7 0}ul.lst-kix_2mkif2f02k9l-0{list-style-type:none}.lst-kix_1i1s9q527gic-1>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-1,lower-latin) ". "}ul.lst-kix_2mkif2f02k9l-1{list-style-type:none}.lst-kix_cbca2endi3u5-3>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-3,decimal) ". "}.lst-kix_cbca2endi3u5-5>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-5,lower-roman) ". "}.lst-kix_9j23me2u28ka-7>li:before{content:"\0025cb   "}.lst-kix_cbca2endi3u5-8>li{counter-increment:lst-ctn-kix_cbca2endi3u5-8}.lst-kix_ec3mu9cmun5s-4>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-4,lower-latin) ". "}ol.lst-kix_ec3mu9cmun5s-3.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-3 0}.lst-kix_cbca2endi3u5-7>li:before{content:"" counter(lst-ctn-kix_cbca2endi3u5-7,lower-latin) ". "}.lst-kix_1i1s9q527gic-5>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-5,lower-roman) ". "}ol.lst-kix_1i1s9q527gic-5.start{counter-reset:lst-ctn-kix_1i1s9q527gic-5 0}.lst-kix_2mkif2f02k9l-0>li:before{content:"\0025cf   "}.lst-kix_ec3mu9cmun5s-2>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-2,lower-roman) ". "}.lst-kix_1i1s9q527gic-0>li{counter-increment:lst-ctn-kix_1i1s9q527gic-0}.lst-kix_1i1s9q527gic-3>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-3,decimal) ". "}ol.lst-kix_1i1s9q527gic-8.start{counter-reset:lst-ctn-kix_1i1s9q527gic-8 0}.lst-kix_ec3mu9cmun5s-0>li:before{content:"" counter(lst-ctn-kix_ec3mu9cmun5s-0,decimal) ". "}ol.lst-kix_ec3mu9cmun5s-6.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-6 0}.lst-kix_eex5n9z85ufq-0>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-0,decimal) ". "}ol.lst-kix_1i1s9q527gic-7.start{counter-reset:lst-ctn-kix_1i1s9q527gic-7 0}ul.lst-kix_9j23me2u28ka-8{list-style-type:none}.lst-kix_eex5n9z85ufq-2>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-2,lower-roman) ". "}.lst-kix_eex5n9z85ufq-4>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-4,lower-latin) ". "}ol.lst-kix_1i1s9q527gic-6{list-style-type:none}.lst-kix_1i1s9q527gic-7>li:before{content:"" counter(lst-ctn-kix_1i1s9q527gic-7,lower-latin) ". "}ol.lst-kix_1i1s9q527gic-7{list-style-type:none}ol.lst-kix_1i1s9q527gic-8{list-style-type:none}.lst-kix_eex5n9z85ufq-6>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-6,decimal) ". "}.lst-kix_eex5n9z85ufq-8>li:before{content:"" counter(lst-ctn-kix_eex5n9z85ufq-8,lower-roman) ". "}.lst-kix_tjheb4thowdp-4>li:before{content:"\0025cb   "}ul.lst-kix_9j23me2u28ka-7{list-style-type:none}ul.lst-kix_9j23me2u28ka-6{list-style-type:none}ol.lst-kix_1i1s9q527gic-0{list-style-type:none}ul.lst-kix_9j23me2u28ka-5{list-style-type:none}ol.lst-kix_1i1s9q527gic-1{list-style-type:none}ul.lst-kix_9j23me2u28ka-4{list-style-type:none}.lst-kix_9j23me2u28ka-5>li:before{content:"\0025a0   "}ol.lst-kix_1i1s9q527gic-2{list-style-type:none}ul.lst-kix_9j23me2u28ka-3{list-style-type:none}ol.lst-kix_1i1s9q527gic-3{list-style-type:none}ul.lst-kix_9j23me2u28ka-2{list-style-type:none}.lst-kix_tjheb4thowdp-6>li:before{content:"\0025cf   "}ol.lst-kix_1i1s9q527gic-4{list-style-type:none}ul.lst-kix_9j23me2u28ka-1{list-style-type:none}ol.lst-kix_1i1s9q527gic-5{list-style-type:none}ul.lst-kix_9j23me2u28ka-0{list-style-type:none}ol.lst-kix_cbca2endi3u5-1.start{counter-reset:lst-ctn-kix_cbca2endi3u5-1 0}.lst-kix_9j23me2u28ka-1>li:before{content:"\0025cb   "}.lst-kix_9j23me2u28ka-3>li:before{content:"\0025cf   "}ol.lst-kix_1i1s9q527gic-6.start{counter-reset:lst-ctn-kix_1i1s9q527gic-6 0}ol.lst-kix_ec3mu9cmun5s-4.start{counter-reset:lst-ctn-kix_ec3mu9cmun5s-4 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_tjheb4thowdp-2>li:before{content:"\0025a0   "}.lst-kix_1i1s9q527gic-7>li{counter-increment:lst-ctn-kix_1i1s9q527gic-7}.lst-kix_eex5n9z85ufq-3>li{counter-increment:lst-ctn-kix_eex5n9z85ufq-3}.lst-kix_cbca2endi3u5-1>li{counter-increment:lst-ctn-kix_cbca2endi3u5-1}.lst-kix_1i1s9q527gic-1>li{counter-increment:lst-ctn-kix_1i1s9q527gic-1}.lst-kix_cbca2endi3u5-7>li{counter-increment:lst-ctn-kix_cbca2endi3u5-7}.lst-kix_tjheb4thowdp-0>li:before{content:"\0025cf   "}ol{margin:0;padding:0}table td,table th{padding:0}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;background-color:#efefef;border-left-style:solid;border-bottom-width:1pt;width:175pt;border-top-color:#000000;border-bottom-style:solid}.c16{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:428.2pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:175pt;border-top-color:#000000;border-bottom-style:solid}.c32{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:422.2pt;border-top-color:#000000;border-bottom-style:solid}.c26{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c28{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Arial";font-style:normal}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c17{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c25{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c19{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Arial";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Roboto Mono";font-style:normal}.c27{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:center}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c2{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Courier New";font-style:normal}.c30{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c14{color:#808080;text-decoration:none;vertical-align:baseline;font-style:italic}.c4{font-size:10pt;font-family:"Courier New";color:#000080;font-weight:700}.c12{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c22{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#0000ee;text-decoration:underline}.c31{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c3{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c11{font-size:10pt;font-family:"Courier New";font-weight:400}.c29{max-width:720pt;padding:36pt 36pt 36pt 36pt}.c15{color:inherit;text-decoration:inherit}.c10{border:1px solid black;margin:5px}.c21{padding:0;margin:0}.c9{margin-left:36pt;padding-left:0pt}.c13{color:#0000ff}.c8{height:11pt}.c5{background-color:#ffffff}.c23{font-weight:700}.c24{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5 c29 doc-content"><p class="c30 title" id="h.lctevg2anp9k"><span class="c28">Transaction Auto-Complete</span></p><p class="c7"><span>Author: </span><span class="c22"><a class="c15" href="mailto:dskarbek@squareup.com">Daniel Skarbek</a></span></p><p class="c7"><span>Date: </span><span>Apr 7, 2023</span></p><p class="c7"><span class="c1">Status: RFC</span></p><p class="c0"><span class="c1"></span></p><h1 class="c17" id="h.44aylmo4xk5w"><span class="c26">Context</span></h1><p class="c7"><span>There are several situations where we would want to start a transaction in PaymentBalances and then complete it upon some trigger event. &nbsp;The most common example is captures (Payment event types) that start off as pending money in transactions and then post when the risk clearing event is received. &nbsp;That&rsquo;s a pending transaction that completes on a trigger. &nbsp;The App-Fee Fraud work we did also exposed some similar situations where a transaction might be started, but held awaiting one or more triggers like the unit being unfrozen or a payment hold being lifted. &nbsp;The system we built for this work ended up </span><span class="c31"><a class="c15" href="https://www.google.com/url?q=https://lucid.app/lucidchart/599a927f-6237-4c86-9eda-b7bacde995d0/edit?invitationId%3Dinv_c2755b7d-0ece-4c00-9592-1f66d5da6449%26page%3D0_0%23&amp;sa=D&amp;source=editors&amp;ust=1689358432242125&amp;usg=AOvVaw0wQEFVN-P_8N1h5I2IpBdt">way too complex</a></span><span>, </span><span>in my opinion</span><sup><a href="#cmnt1" id="cmnt_ref1">[a]</a></sup><sup><a href="#cmnt2" id="cmnt_ref2">[b]</a></sup><span class="c1">. &nbsp;So, I&rsquo;m seeing several cases here that all seem to call for some sort of complete-on-trigger behavior and I think we can build a generalized solution in PaymentBalances that will serve all these cases and more in the future.</span></p><h1 class="c17" id="h.blsztl7s23lc"><span class="c26">Requirements</span></h1><ul class="c21 lst-kix_9j23me2u28ka-0 start"><li class="c7 c9 li-bullet-0"><span class="c1">The details of a payment come in on the Capture event and should create a pending transaction which then posts when a risk cleared signal for that payment comes in. &nbsp;All the information needed for the transaction is on the Capture event.</span></li><li class="c7 c9 li-bullet-0"><span class="c1">When an App Fee is present on a payment (Capture event), there are two more transactions created: one to debit the fee from the seller (AppFee type) and one to credit the fee to the developer. &nbsp;These are in addition to the normal payment type activity, but they also should only be pending and should post when the risk clear signal comes in (if none of the following exceptions apply).</span></li><li class="c7 c9 li-bullet-0"><span class="c1">If a payment is held at the time that the transaction to the developer would post then it is not posted until the hold is released.</span></li><li class="c7 c9 li-bullet-0"><span>If a seller is frozen at the time that the transaction to the developer would post then it is not posted until the seller is unfrozen.</span><sup><a href="#cmnt3" id="cmnt_ref3">[c]</a></sup><sup><a href="#cmnt4" id="cmnt_ref4">[d]</a></sup></li><li class="c7 c9 li-bullet-0"><span>If a payment hold and seller freeze are both in place, then both must be cleared for the transaction to the developer to post, and this state should be checked at the point of posting the transaction &ndash; meaning if a transaction is held for a payment hold, when that hold is released, we should check again that the seller is not now frozen.</span></li></ul><sup><a href="#cmnt5" id="cmnt_ref5">[e]</a></sup><sup><a href="#cmnt6" id="cmnt_ref6">[f]</a></sup><sup><a href="#cmnt7" id="cmnt_ref7">[g]</a></sup><sup><a href="#cmnt8" id="cmnt_ref8">[h]</a></sup><sup><a href="#cmnt9" id="cmnt_ref9">[i]</a></sup><sup><a href="#cmnt10" id="cmnt_ref10">[j]</a></sup><h1 class="c17" id="h.jrlomrmx5pwv"><span class="c26">Commonalities and Domain Models</span></h1><p class="c7"><span class="c1">A few generalizable patterns I see in the above:</span></p><ul class="c21 lst-kix_2mkif2f02k9l-0 start"><li class="c7 c9 li-bullet-0"><span class="c1">One event specifies all the details of a transaction, but it&rsquo;s only pending until another event (or several others) happen.</span></li><li class="c7 c9 li-bullet-0"><span class="c1">Those events might happen close together and race with each other and we&rsquo;d like to handle the case where the triggering event shows up before the triggered event.</span></li><li class="c7 c9 li-bullet-0"><span class="c1">We might depend on a state (like the seller being unfrozen) that is true at transaction creation time, but then by the time the other things we were waiting on (like risk review) come along, that state is no longer true, so we need a way to specify conditions that must remain true and could become blockers in the future.</span></li></ul><p class="c7"><span class="c1">I want to add some support in PaymentBalance for abstracting the handling of these issues and other concepts as needed to support the pattern.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span>At a domain modeling level, I expect PaymentBalances to be focused on accounts and activities and transactions and only opaquely aware of outside concerns. &nbsp;So, an activity has a type like &ldquo;payment&rdquo; or &ldquo;refund&rdquo; or &ldquo;fee&rdquo; or &ldquo;hold&rdquo; but those are just random strings to the PaymentBalances domain. &nbsp;Concepts like &ldquo;freeze&rdquo; and &ldquo;payment hold&rdquo; or even &ldquo;payment&rdquo; should be owned by </span><span>external domains that we just get notified from</span><sup><a href="#cmnt11" id="cmnt_ref11">[k]</a></sup><sup><a href="#cmnt12" id="cmnt_ref12">[l]</a></sup><sup><a href="#cmnt13" id="cmnt_ref13">[m]</a></sup><span class="c1">. &nbsp;Meaning, PaymentClearing consumes the esperanto feed and responds by creating transactions in PaymentBalances, but PaymentBalances isn&rsquo;t the system of record for payment data. &nbsp;Similarly with freeze statuses, we are notified of them being placed and lifted, but we don&rsquo;t own that model. &nbsp;But, we also don&rsquo;t have a generic interface. &nbsp;We have &ldquo;refund id&rdquo;s and stuff like that in our details, not generic &ldquo;metadata&rdquo; keys and values. &nbsp;The underlying implementation is generic and we take this data as client reference data, but we model the specific names in the interface so that we can constrain the interface appropriately.</span></p><h1 class="c17" id="h.ee4dis831ndq"><span class="c26">Proposal</span></h1><p class="c7"><span class="c1">The basic concepts the PaymentBalances domain should work with are:</span></p><ul class="c21 lst-kix_tjheb4thowdp-0 start"><li class="c7 c9 li-bullet-0"><span class="c23">Transaction</span><span>: can be pending and then </span><span>canceled</span><sup><a href="#cmnt14" id="cmnt_ref14">[n]</a></sup><sup><a href="#cmnt15" id="cmnt_ref15">[o]</a></sup><sup><a href="#cmnt16" id="cmnt_ref16">[p]</a></sup><sup><a href="#cmnt17" id="cmnt_ref17">[q]</a></sup><span class="c1">&nbsp;or completed. &nbsp;Creates activities on the account. &nbsp;Clients can get pending transactions and perform complete or cancel operations on them.</span></li><li class="c7 c9 li-bullet-0"><span class="c23">Signal</span><span class="c1">: A key and value. &nbsp;Probably modeled to more specific types in the interface. &nbsp;Would start with things like hold status, freeze status, and risk review. &nbsp;Clients can post an updated signal state to PaymentBalances. &nbsp;It isn&rsquo;t needed yet, and would be a different implementation needed, but we could have a time signal also to do things like auto-canceling after a certain amount of time.</span></li><li class="c7 c9 li-bullet-0"><span class="c23">Trigger</span><span class="c1">: a transaction should be able to be created with a trigger condition (or set of conditions) which can automate activities on that transaction such as completing it or canceling it (though all current cases are for auto-complete). Triggers would be like a boolean expression watching for certain signals to be in certain states, at which point the effect is triggered.</span></li></ul><h3 class="c25" id="h.6wcpjgs73stc"><span class="c19">Signal Storage</span></h3><p class="c7"><span class="c1">We would maintain a durable but temporary store of signal state. &nbsp;We are not the SOR for this data, so we don&rsquo;t need to store it permanently, but this is also more durable than a cache. &nbsp;We have no fall-back system to read from, so while we are holding the data we need to hold it accurately and reliably. &nbsp;We would maintain a store of transactions that are waiting on signals, so we would know which signals we care about. &nbsp;As long as a signal is watched by a transaction, we would retain that data. &nbsp;But, once it is unreferenced we would delete it after a day. &nbsp;The one day delay gives us a short buffer time to account for race conditions of a signal update coming in before the transaction that wants to watch it.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span>At first we would want to record risk review, payment hold, and seller freeze signals. &nbsp;Risk review is a one way signal, you don&rsquo;t have it and then you do. &nbsp;It doesn&rsquo;t go back. &nbsp;The holds and freezes can go off and on, so just because a hold is not in place at first, doesn&rsquo;t mean it wouldn&rsquo;t be created later. &nbsp;</span><span>We will send all signal updates to PaymentBalances, and we will store all of them, but then the ones that aren&rsquo;t watched by anything a day later will be deleted.</span><sup><a href="#cmnt18" id="cmnt_ref18">[r]</a></sup><sup><a href="#cmnt19" id="cmnt_ref19">[s]</a></sup><sup><a href="#cmnt20" id="cmnt_ref20">[t]</a></sup></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">We&rsquo;ll add a signal operation to PayBal that allows clients to update a signal status. We don&rsquo;t want to have to make a separate API for each type of signal we may add, so instead we will have a &ldquo;one of&rdquo; style input.</span></p><p class="c0"><span class="c1"></span></p><a id="t.d98405ed96b2328c730785f72daccdfaedb8ef2b"></a><a id="t.0"></a><table class="c12"><tr class="c24"><td class="c16" colspan="1" rowspan="1"><p class="c3 c5"><span class="c4">message </span><span class="c2">RiskPaymentClearSignal {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required string </span><span class="c11">payment_id = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c14 c11">/* no value is needed because the inference is that it is cleared */</span></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c8 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">PaymentHoldSignal {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required string </span><span class="c11">payment_id = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required bool </span><span class="c11">is_held = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c8 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">SellerFreezeSignal {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required string </span><span class="c11">location_id = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required bool </span><span class="c11">is_frozen = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c8 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">UpdateSignalRequest {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">oneof </span><span class="c2">signal {</span></p><p class="c3 c5"><span class="c11">&nbsp; &nbsp;RiskPaymentClearSignal risk_clear_signal = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp; &nbsp;PaymentHoldSignal hold_signal = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp; &nbsp;SellerFreezeSignal freeze_signal = </span><span class="c11 c13">3</span><span class="c2">;</span></p><p class="c3 c5"><span class="c2">&nbsp;}</span></p><p class="c3 c5"><span class="c11">}</span></p></td></tr></table><p class="c7"><span>When a signal state is updated, the storage is updated and then an event about the update should be enqueued so that a system that looks for transactions to trigger based on that state change can run asynchronously.</span></p><h3 class="c25" id="h.ctr27wiqult1"><span>Create Transactions with Triggers</span><sup><a href="#cmnt21" id="cmnt_ref21">[u]</a></sup><sup><a href="#cmnt22" id="cmnt_ref22">[v]</a></sup><sup><a href="#cmnt23" id="cmnt_ref23">[w]</a></sup><sup><a href="#cmnt24" id="cmnt_ref24">[x]</a></sup></h3><p class="c7"><span>When a new transaction is being created in PaymentBalances, if it is a pending transaction, there should be a way to specify a set of signals to watch, which when met will cause the transaction to automatically be completed (or canceled). &nbsp;The next question is if multiple triggers are an &ldquo;and&rdquo; condition or an &ldquo;or&rdquo; condition. &nbsp;The basic functionality we need for the existing use-cases is &ldquo;and&rdquo;; the transaction should auto-complete when all triggers are met. &nbsp;But, we could build in some more flexibility by supporting an </span><span>or-list of and-lists</span><sup><a href="#cmnt25" id="cmnt_ref25">[y]</a></sup><sup><a href="#cmnt26" id="cmnt_ref26">[z]</a></sup><sup><a href="#cmnt27" id="cmnt_ref27">[aa]</a></sup><span class="c1">&nbsp;of triggers. &nbsp;</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span>Finally, it should not be assumed that all signals being watched are unmet and need meeting. &nbsp;</span><span>A transaction might specify that a seller can&rsquo;t be frozen, and as far as the client knows it is not currently frozen, but they still want to watch and ensure that it doesn&rsquo;t become frozen. &nbsp;But, because no transaction has been watching that seller freeze signal, the signal store may not have been keeping the state of that signal around.</span><sup><a href="#cmnt28" id="cmnt_ref28">[ab]</a></sup><span class="c1">&nbsp; So, we need to require that clients check the current state of what they depend on and be able to specify what they believe the current signal state to be when they are submitting a trigger. &nbsp;This should not override or change the signal state if we do have it stored, but just provide a default value if the state is null. &nbsp;In fact, we won&rsquo;t even update the signal state if it is missing, just keep this default value as part of the trigger for when we evaluate it. &nbsp;This does mean that we need a slightly different set of objects for watching a signal.</span></p><a id="t.21427c022b8b1a996ae35edbeae97010c641ee2f"></a><a id="t.1"></a><table class="c12"><tr class="c24"><td class="c32" colspan="1" rowspan="1"><p class="c3 c5"><span class="c4">message </span><span class="c2">RiskPaymentClearSignalWatch {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required string </span><span class="c11">payment_id = </span><span class="c11 c13">1</span><span class="c11">;</span><sup><a href="#cmnt29" id="cmnt_ref29">[ac]</a></sup><sup><a href="#cmnt30" id="cmnt_ref30">[ad]</a></sup><sup><a href="#cmnt31" id="cmnt_ref31">[ae]</a></sup><sup><a href="#cmnt32" id="cmnt_ref32">[af]</a></sup></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c14 c11">/* no value is needed because the inference is we are watching</span></p><p class="c3 c5"><span class="c11 c14">&nbsp; for it to show up and it hasn&#39;t shown up yet */</span></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c5 c8"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">PaymentHoldSignalWatch {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required string </span><span class="c11">payment_id = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required bool </span><span class="c11">watch_for_is_held_is = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">optional bool </span><span class="c11">currently_is_held = </span><span class="c11 c13">3</span><span class="c11">;</span><sup><a href="#cmnt33" id="cmnt_ref33">[ag]</a></sup><sup><a href="#cmnt34" id="cmnt_ref34">[ah]</a></sup></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c8 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">SellerFreezeSignalWatch {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required string </span><span class="c11">location_id = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">required bool </span><span class="c11">watch_for_is_frozen_is = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">optional bool </span><span class="c11">currently_is_frozen = </span><span class="c11 c13">3</span><span class="c2">;</span></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c8 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">WatchForAll {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">repeated </span><span class="c11">RiskPaymentClearSignalWatch risk_clear_watch = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">repeated </span><span class="c11">PaymentHoldSignalWatch hold_watch = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">repeated </span><span class="c11">SellerFreezeSignalWatch freeze_watch = </span><span class="c11 c13">3</span><span class="c2">;</span></p><p class="c3 c5"><span class="c2">}</span></p><p class="c3 c8 c5"><span class="c2"></span></p><p class="c3 c5"><span class="c4">message </span><span class="c2">Transaction {</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">repeated </span><span class="c11">WatchForAll trigger_auto_complete_on_any = </span><span class="c11 c13">1</span><span class="c2">;</span></p><p class="c3 c5"><span class="c11">&nbsp;</span><span class="c4">repeated </span><span class="c11">WatchForAll trigger_auto_cancel_on_any = </span><span class="c11 c13">2</span><span class="c2">;</span></p><p class="c3 c5"><span class="c2">}</span></p></td></tr></table><p class="c7"><span class="c1">We don&rsquo;t need a &ldquo;oneof&rdquo; in the WatchForAll because this is a collection of multiple things to watch for where they must all be met, so we can just have separate lists of the kinds of watches. &nbsp;Realistically, it&rsquo;s unlikely you&rsquo;d have more than one of a given kind of watch, but might as well allow the possibility that you want to watch for a freeze on any of a number of locations, or something like that. &nbsp;Each WatchForAll then is a collection of watches that all must pass at a given time, and the trigger is a list of WatchForAll&rsquo;s any of which could activate the trigger. &nbsp;Hence, this is our &ldquo;or-list of and-lists.&rdquo;</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span>Note that a Payment Hold or Seller Freeze watch that specifies false as the watched for value (the only real case we expect for now) and also specifies false as the current value is a watch that is already satisfied. &nbsp;This would happen when a client checks the freeze state (for example) and then files the transaction. &nbsp;The client is saying that it&rsquo;s not a blocker now, but if something comes up then it should become a blocker. &nbsp;And, it&rsquo;s important that the client does do this check because the PaymentBalances system is not guaranteeing to have complete, perfect state for all possible signals. &nbsp;</span><span>We also don&rsquo;t immediately update the Signal store with the current value when the transaction is submitted even if it&rsquo;s missing because there might be a great many sellers with transactions that are saying &ldquo;make sure it doesn&rsquo;t get frozen&rdquo; but very few sellers that actually get frozen. </span><sup><a href="#cmnt35" id="cmnt_ref35">[ai]</a></sup><sup><a href="#cmnt36" id="cmnt_ref36">[aj]</a></sup><sup><a href="#cmnt37" id="cmnt_ref37">[ak]</a></sup><sup><a href="#cmnt38" id="cmnt_ref38">[al]</a></sup><sup><a href="#cmnt39" id="cmnt_ref39">[am]</a></sup><span class="c1">&nbsp;So, we don&rsquo;t want to inundate the Signal store with these current values that may never be updated and we can just read them off the transaction when evaluating the trigger.</span></p><h3 class="c25" id="h.qzgngpp91ita"><span class="c19">Use Cases</span></h3><p class="c7"><span class="c1">The standard capture use case would create a transaction for a credit to the seller&rsquo;s account with a RiskPaymentClearSignalWatch to trigger completion of the transaction. &nbsp;The Magistrate feed will be consumed by ledger and turned into a RiskPaymentClearSignal to PayBal which will trigger the transaction to complete.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span>In the case of an app fee on the capture, there are two additional transactions, a debit from the seller&rsquo;s account for the app fee amount, and a credit to the developer&rsquo;s account. &nbsp;Both of these transactions will also have a RiskPaymentClearSignalWatch on them. &nbsp;</span><span>The credit to the developer will also have payment hold and seller freeze watches.</span><sup><a href="#cmnt40" id="cmnt_ref40">[an]</a></sup><sup><a href="#cmnt41" id="cmnt_ref41">[ao]</a></sup><sup><a href="#cmnt42" id="cmnt_ref42">[ap]</a></sup><span class="c1">&nbsp; (All in one WatchForAll item.) &nbsp;The ledger code will check the current hold and freeze status to pass that in on the watches.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">The PaymentHold and release events are already processed by PaymentBalances to move the money in and out, but would now also need to include a signal being issued. &nbsp;The seller freeze and unfreeze operations are not currently causing an balance change, but they would need to be instrumented to issue the signal calls to PaymentBalances. &nbsp;(Or PayBal would need to consume a feed of these changes to get the signals from them.)</span></p><h1 class="c17" id="h.ukqu0b53aiwr"><span class="c26">Architecture</span></h1><h3 class="c27" id="h.9v6f0z3mvxhc"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 837.39px; height: 396.66px;"><img alt="" src="images/image2.png" style="width: 837.39px; height: 396.66px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><p class="c7"><span>When PaymentBalances receives a transaction, it will create the pending transaction in FinancialAccount </span><span>with the trigger data stored in the metadata</span><sup><a href="#cmnt43" id="cmnt_ref43">[aq]</a></sup><sup><a href="#cmnt44" id="cmnt_ref44">[ar]</a></sup><sup><a href="#cmnt45" id="cmnt_ref45">[as]</a></sup><sup><a href="#cmnt46" id="cmnt_ref46">[at]</a></sup><span class="c1">. &nbsp;This is then picked up in the feed listener and put into the trigger store. &nbsp;We could then directly invoke the trigger processor to see if it&rsquo;s immediately complete, or since we have to have a DB stream event for the signals, we can also just let that detect the new trigger as well. &nbsp;The essential thing is that the trigger is committed to the Trigger Store before the Trigger Processor logic starts. &nbsp;When a signal is reported it is written to the signal store and then the change is streamed to the trigger processing code to see what triggers may now be satisfied. &nbsp;When the trigger processing code determines that a trigger is satisfied it calls FinancialAccount to complete (or cancel) the transaction and then deletes the trigger. &nbsp;There&rsquo;s also a cron-job process that watches for old signals that are no longer referenced and deletes them.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span>Because the Signal Action and Transaction Action processes both just write to a single system, those are transactional on failures. &nbsp;The systems that have to coordinate between multiple systems are triggered by our own event streams so that we can guarantee that things will retry on failure. &nbsp;This ensures that we don&rsquo;t leave things in half done states if there are any errors. &nbsp;So, the use of event streams here gives us transactional failure behavior, and it also is robust against race conditions. &nbsp;Because the stores are written to before the event about that data is fired and responded to, there is a serialization that happens. &nbsp;It isn&rsquo;t possible that both a trigger and signal come in and look for each other and neither sees the other. &nbsp;Because the looking (in the Trigger Processor) happens strictly after the store is updated, so if it doesn&rsquo;t see something, that other thing must not have been stored yet, which means it must not have streamed to the Trigger Processor yet, which means when it does, the first thing is guaranteed to be there. &nbsp;So, no matter how a trigger creation and a signal race with each other, the trigger will get evaluated when the second one arrives and it will see the first one. &nbsp;The one caveat there is when the &ldquo;first one&rdquo; is the signal and it&rsquo;s over a day old. &nbsp;That&rsquo;s why it is expected / required that </span><span>clients</span><sup><a href="#cmnt47" id="cmnt_ref47">[au]</a></sup><span>&nbsp;creating the transactions and triggers are checking the business logic behind the signals and are </span><span>sending in the current state that they have observed</span><sup><a href="#cmnt48" id="cmnt_ref48">[av]</a></sup><span class="c1">.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">Finally, note that it is possible that one signal is watched by multiple triggers. &nbsp;In fact potentially watched by an extremely large number of triggers. &nbsp;Imagine a high volume seller, doing millions of transactions, that happens to be frozen. &nbsp;Then they get unfrozen. &nbsp;That one signal will trigger millions of transactions to complete. &nbsp;So, we can&rsquo;t assume that the trigger processor can successfully process everything in a single process. &nbsp;It needs to be capable of batching the work. &nbsp;Fortunately, the fact that it&rsquo;s working off of a stream event makes this easier. &nbsp;The Trigger Processor will search for triggers that possibly match the signal, up to some limit, process them, and then attempt to repeat. &nbsp;If the process dies or errors, then the event is not marked complete and will be retried. &nbsp;When it is retried, some of the triggers have already been processed and so the job has made some progress and resumes. &nbsp;</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">At least, that&rsquo;s the idea. &nbsp;There&rsquo;s a few details to making this really work well. &nbsp;Firstly, the common case is that the process doesn&rsquo;t die and just works through one batch after another and it all makes sense, but how does it know where &ldquo;one batch after another&rdquo; is? &nbsp;It should be that each time it queries for things to work on it is finding fewer things to work, how does that happen? &nbsp;It should be happening because the completed triggers are being deleted. &nbsp;So, it&rsquo;s important that the deleting of triggers is a synchronous part of the batch processing. &nbsp;But, what if the signal is not the last watch the triggers are waiting on? &nbsp;We are querying for triggers that are watching the signal we are processing, but what if there are other signals that haven&rsquo;t happened yet? &nbsp;We&rsquo;re partly saved by the fact that only seller freeze is likely to really impact a lot of transactions and the other signals are payment specific and so will only effect a few transactions at most. &nbsp;That means that either the total set of rows to look at is small, or the number of rows blocked by another signal are small. &nbsp;But, what if lots of payments are held on the newly unfrozen seller. &nbsp;We could still have a whole batch fetch be unprocessable triggers which would stop all progress. &nbsp;And, even if it isn&rsquo;t that bad, we don&rsquo;t want to sand-bag each fetch with more and more unprocessable triggers. &nbsp;Plus we want this system to be able to handle future triggers and signals that may not be so nice in this way. &nbsp;There are a few potential solutions.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">We can add a timestamp or id filter to the batch query. &nbsp;Anything that sequences the items such that the new items are at the end and we can have a cursor to work through the results &ndash; much like we would do on a list end-point that has to return a cursor for subsequent fetches. &nbsp;We can use this in the process that is working through the batch. &nbsp;If the process dies or errors and has to restart, it will have to start over with the evaluation, but that should be more rare. &nbsp;In general, a process will eventually succeed in scanning all the items of the batch.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">The above cursor solution relies on having an in-memory cursor which means it works so long as the process doesn&rsquo;t keep dying. &nbsp;But that means it is vulnerable to a &ldquo;poison pill.&rdquo; &nbsp;If there is a invalid trigger item that causes the code to error, then it will cause the process to die and restart and will keep doing that indefinitely causing it to never succeed. &nbsp;Essentially, any permanent error will be fatal and can&rsquo;t be worked around. &nbsp;Also, if there really is that much work to do, it&rsquo;s unfortunate to not be able to parallelize it. &nbsp;We can address both those concerns by having a secondary work queue where each trigger to assess is a separate item. &nbsp;This would work by having the event that responds to the signal just find all the triggers that might be connected and enqueue separate events for each of them. &nbsp;Then they can all be worked in parallel. &nbsp;Because this fan-out process is just reading and publishing what it finds, it is much less likely to die. &nbsp;If it did, in the worst case, some triggers would be re-published and evaluated twice, but that is idempotent. &nbsp;You would have to use some sort of fetch query cursor in this process to ensure you can progress through an unbounded list of items, publishing them all to the secondary queue, but you would basically trust that it won&rsquo;t be hard for the process to stay alive long enough to do this.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">Finally, an alternate approach to this is to structure the fetch query such that it only fetches triggers that are fully satisfied. &nbsp;Then they will all be deleted as they are worked and you are guaranteed that the query will keep finding new data to work until it finds nothing and you are done. &nbsp;But, how do you structure such a query? &nbsp;It would need to first filter by all triggers that are watching the input signal for the value it is now at. &nbsp;But it would then also need to evaluate, in the query, that all other signals the trigger is watching are satisfied. &nbsp;That means joining in data about other signals. &nbsp;DynamoDB is probably not able to do this. &nbsp;This is a job for a relational database, but even in that case, we would have to investigate whether we can really efficiently do a SQL query with a join in the where clause. &nbsp;That&rsquo;s an expert level of query crafting there. &nbsp;Worth investigating as an option, but questionable.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">One last interesting point to make about the architecture proposed: it&rsquo;s completely isolated. &nbsp;I&rsquo;ve been talking about it as something added to the PaymentBalances service, but really it could be an independent service. &nbsp;It needs to expose the signal end-point, consume the FinAct transaction feed (or maybe even the PaymentBalances feed) and call the FinAct service to complete or cancel transactions (or call the PaymentBalances service). &nbsp;But, none of that requires it to be internal to FinAct or PayBal. &nbsp;The rest of it is totally self contained. &nbsp;Nobody else needs to be able to see the Signal and Trigger data stores. &nbsp;If it was external to PayBal, there&rsquo;s a little bit of a hidden data interface in that there would have to be an agreement about what metadata keys it is watching for and clients would need to know about that special behavior. &nbsp;That&rsquo;s maybe the one point that argues for keeping it inside PaymentBalances so that metadata agreement is private, but something to keep in mind as an option. &nbsp;This could be an independent service, and it could be built to work at the FinAct level on any tenant.</span></p><h1 class="c17" id="h.mgkpephl8vlq"><span class="c26">Alternative Approach / Architecture</span></h1><p class="c7"><span class="c1">Rather than having PayBal provide an auto-clearing behavior, we could build an independent call-back / notifier system. &nbsp;This would be like a fine grained messaging system. &nbsp;(In that short-lived clients are listening for very fine-grained events &ndash; topics that will only ever have one message.) &nbsp;When recording a transaction, ledger could register with the system what callbacks / signals it is waiting for. &nbsp;The system would put an event in a queue back to ledger when it was time to reconsider an item. &nbsp;Some signals/triggers could be handled automatically by the signaling system.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">A caller (i.e. Ledger) would register a callback, potentially purely by publishing to an SQS feed. &nbsp;This reminder service may be entirely event driven. &nbsp;The advantage being easy retry-on-failure semantics. &nbsp;So, Ledger publishes a subscription message that indicates the signals they are waiting for and the payload to deliver when all signals are cleared.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">Ledger publishes signals to an SQS queue. &nbsp;Signals are generalized as type, key, and value pairs. </span></p><p class="c0"><span class="c1"></span></p><a id="t.93f97e2d92321aad3ef4c4511f57b0a511e9c130"></a><a id="t.2"></a><table class="c12"><tr class="c24"><td class="c18" colspan="1" rowspan="1"><p class="c3"><span class="c1">Type</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c3"><span class="c1">Key</span></p></td><td class="c18" colspan="1" rowspan="1"><p class="c3"><span class="c1">Value</span></p></td></tr><tr class="c24"><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">RISK_PAYMENT_STATUS</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">Payment Token</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">Status &ndash; typically AUTOMATICALLY_REVIEWED</span></p></td></tr><tr class="c24"><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">PAYMENT_HOLD</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">Payment Token</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">Held / Released</span></p></td></tr><tr class="c24"><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">SELLER_FREEZE</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">Unit Token</span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c3"><span class="c1">FROZEN / UNFROZEN</span></p></td></tr></table><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">When a new signal with the same type and key shows up, the stored value is updated. &nbsp;Ledger also registers call-backs via the SQS queue. &nbsp;The call back has some payload which should be published on the condition that the signals are met. &nbsp;Once the signals come in, it publishes the payload. &nbsp;In fact, the callback registration could include the kafka topic to publish to and the payload to publish so it&rsquo;s generic. &nbsp;We can support &ldquo;any of&rdquo; vs. &ldquo;all of&rdquo; like in the above proposal where we have an &ldquo;any of&rdquo; list of &ldquo;all of&rdquo; conditions. &nbsp;</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">Ledger can use this system to publish a pending transaction in PayBal and then register a callback for the conditions that it is waiting on before posting the transaction. &nbsp;When it gets the call back, it can check for any new blockers and then either re-enqueue a callback for the new blockers, or post the transaction.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">One of the key capabilities that the system will provide is holding signals for a day and applying them to callback requests that arrive after them (within a day). &nbsp;This mitigates any race condition concerns. &nbsp;There is a consistency concern with creating a pending transaction with PayBal and then having to create a callback in this system atomically. &nbsp;This would be a problem for clients to solve. &nbsp;In the case of ledger, it would be handled by the fact that this is all happening from the AQ handlers. &nbsp;So, we have a simple retry mechanism. &nbsp;But other approaches would be things like pre-generating a ledger entry token and publishing the callback first. &nbsp;If the PayBal call fails then the callback would turn into a no-op.</span></p><p class="c0"><span class="c1"></span></p><p class="c7"><span class="c1">The purpose of the queue on incoming signals is because a signal might trigger a large number of callbacks and we want the ability to retry and eventually succeed and to batch the processing of resultant actions. &nbsp;We could have a queue that clients directly publish to. &nbsp;Or, we could have an RPC interface that just writes to Dynamo and then a DynamoStreams process does the async processing.</span></p><p class="c0"><span class="c1"></span></p><h3 class="c27" id="h.hvowdp8tnel8"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 837.39px; height: 208.06px;"><img alt="" src="images/image1.png" style="width: 837.39px; height: 208.06px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h3><div class="c10"><p class="c3"><a href="#cmnt_ref1" id="cmnt1">[a]</a><span class="c1">Definitely agree there, it requires too much work to untangle</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref2" id="cmnt2">[b]</a><span class="c1">That Lucidchart is scary.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref3" id="cmnt3">[c]</a><span class="c1">Could a unit freeze just freeze payouts? Do we need to apply the freeze to &quot;money in&quot;?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref4" id="cmnt4">[d]</a><span class="c1">From reading below, sounds like we care about unit freezes for developer fees, which are essentially payouts because money is changing hands.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref5" id="cmnt5">[e]</a><span class="c1">To clarify, for the last three cases, as long as there&#39;s a hold on payment or on merchant or on both, merchants and developers will not receive any posted events even when risk is cleared. It is when no hold is present, then merchant and developer will get credit/debit at the same time.&nbsp;</span></p><p class="c3"><span class="c1">This makes sense to me but just want to confirm my understanding.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref6" id="cmnt6">[f]</a><span class="c1">a hold on the merchant doesn&#39;t block the app fee&#39;s because that&#39;s just an amount of money being held from their balance.&nbsp; But a freeze on the merchant&nbsp;or a hold on that particular payment will block the app fee.&nbsp; When it does that, it blocks the money going to the developer, but the money is taken from the merchant.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref7" id="cmnt7">[g]</a><span class="c1">I see, and in all these cases, merchant is always debited, it&#39;s just only when hold is on merchant then app fee is credit other wise the credit is blocked.</span></p><p class="c3"><span class="c1">What is the difference between a merchant being on held vs frozen?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref8" id="cmnt8">[h]</a><span class="c1">For our purposes, not much.&nbsp; A freeze says the whole unit/location can&#39;t exit funds.&nbsp; A payment hold says the funds from that one payment are not available.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref9" id="cmnt9">[i]</a><span class="c1">I see. Basically three hold/freeze scenarios: 1) Hold on a payment 2) Merchant freeze 3) Hold an arbitrary amount from a merchant. We will not credit developer in 1) and 2).</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref10" id="cmnt10">[j]</a><span class="c1">right</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref11" id="cmnt11">[k]</a><span class="c1">Is there already a plan on Risk taking freezes and holds out of Ledger? I guess Freezes would actually be set in the Payout Configurations layer since it&#39;s only settlement related so I guess maybe&nbsp;holds should also go there? Though Risk is the one telling us what to do so not sure but that&#39;s probably a question for later</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref12" id="cmnt12">[l]</a><span class="c1">There isn&#39;t a solid plan yet -- certainly nothing committed.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref13" id="cmnt13">[m]</a><span class="c1">Turns out that Risk is not the only producer of freezes, so it doesn&#39;t make sense for Risk to own them. I forget where else freezes can come from -- I think compliance-related things.</span></p><p class="c3 c8"><span class="c1"></span></p><p class="c3"><span class="c1">We are also not the only consumers of freezes -- Square Checking / Savings consumes them, too. Any team that can exit money from Square cares about freezes.</span></p><p class="c3 c8"><span class="c1"></span></p><p class="c3"><span class="c1">So it&#39;s a many-to-many relationship between freeze producers and consumers. There&#39;s not a clear owner and probably never will be. Since we currently own them, we&#39;re probably stuck with them because we can&#39;t make a strong case that someone else should own them.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref14" id="cmnt14">[n]</a><span class="c1">Interesting case. In Payment Balance realm, sounds like we don&#39;t have the transaction cancel scenario for now?&nbsp;</span></p><p class="c3"><span class="c1">What is the potential use case in the future and how it would get represented in Books?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref15" id="cmnt15">[o]</a><span class="c1">yeah, there&#39;s no actual use-case for this yet, but if you wanted to have a transaction that automatically clears after&nbsp;a certain amount of time (like an auth that clears if not captured) then I would add some special support for time based signals and that would be a trigger to cancel scenario.&nbsp; Also possible that we have a case where we go one way or another based on a signal and so one pending transaction completes on the signal and the other cancels.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref16" id="cmnt16">[p]</a><span class="c1">For the auto-clear scenario, should the transaction be auto-completed instead of auto-canceled if we haven&#39;t received signals for a while? In Ledger, so far, a pending transaction is a happened transaction so it can&#39;t be canceled?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref17" id="cmnt17">[q]</a><span class="c1">sure, that&#39;s a possible use-case also -- there could be an &quot;or x time has passed&quot; trigger on a capture.&nbsp; I think that&#39;s a feature to come later if we need it.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref18" id="cmnt18">[r]</a><span class="c1">This basically allows one day for payment&nbsp;to catch up the risk signal in our current case.&nbsp;</span></p><p class="c3"><span class="c1">That should enough for normal risk case, but I wonder if it&#39;s worth it to only delete signal after it&#39;s consumed. That&#39;ll add one additional field to indicate if a signal is consumed or not, but guarantees all signals are consumed before deleted.&nbsp;</span></p><p class="c3"><span class="c1">And for duplicated signals we could set a longer TTL before it&#39;s deleted. However this approach will disrupt&nbsp;the full asynchronous&nbsp;flow for PB to consume signals and update.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref19" id="cmnt19">[s]</a><span class="c1">yeah, my issue with marking consumption is that there can be multiple consumers and there could be tight races on whether it&#39;s actually going to be consumed or not.&nbsp; The day really should be a wide buffer.&nbsp; This is just for races really.&nbsp; If a hold or freeze is created just after we check for it while filing the transaction, or if the risk signal gets there before the transaction.&nbsp; That&#39;s the most common case -- when we&#39;re lagging on one of the feeds.&nbsp; I think a day gives us plenty of buffer room.&nbsp; In a catastrophic scenario where we violate that, we would rewind the risk feed to re-ingest the signals.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref20" id="cmnt20">[t]</a><span class="c1">Makes sense.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref21" id="cmnt21">[u]</a><span class="c1">A big question I have is what system is in charge of creating these transactions with triggers and how they should decide what signals each transaction should watch? And do we allow updates and changes to the `WatchForAll` condition set? What we do if there&#39;s a race condition between a signal to clear the transaction and a trigger condition change that request another signal watch?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref22" id="cmnt22">[v]</a><span class="c1">The Payment Clearing (ledger) system would be the one creating these, and the design is that they don&#39;t get modified.&nbsp; That&#39;s why you can include things in your trigger that you think are already&nbsp;met (like freezes and holds) so that they will become a required condition if something updates.&nbsp; That&#39;s how we avoid needing to modify the trigger over time.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref23" id="cmnt23">[w]</a><span class="c1">I see. The concept seems to shift from blocker-clearing system to the checklist-meeting system with this design. And I imagine to be safe, clearing&nbsp;system&nbsp;would always try to err&nbsp;on the side of including too many triggers. The passed around trigger data could grow long but ideally it shouldn&#39;t be a concern IMO.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref24" id="cmnt24">[x]</a><span class="c1">Yeah, like the app fee credit to developer transaction is always going to include payment hold and unit freeze watches in its trigger, but it is checking this data today already.&nbsp; So, it&#39;s just attaching and passing this data through.&nbsp; I doubt the list of things to watch would grow that much.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref25" id="cmnt25">[y]</a><span class="c1">I think so far we don&#39;t have use case for these ones yet?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref26" id="cmnt26">[z]</a><span class="c1">Correct.&nbsp; Currently, the most complicated case would be one of each kind of watch in a single &quot;watch for all&quot;.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref27" id="cmnt27">[aa]</a><span class="c1">&#x1f44d;</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref28" id="cmnt28">[ab]</a><span class="c1">Does this only apply to unit/seller-level signals? Could we just keep those around forever (not delete them after a day)? There aren&#39;t that many of them (single-digit millions).</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref29" id="cmnt29">[ac]</a><span class="c1">Will we differentiate a received risk signal &quot;CONCERN&quot; with not receiving a risk signal?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref30" id="cmnt30">[ad]</a><span class="c1">I&#39;m thinking that we&#39;d model it as just cleared or not.&nbsp; The transaction system doesn&#39;t care about pending manual review or whatever.&nbsp; We could actually send the risk review state in and watch for a specific value if we thought we might want that, but I was proposing it as a more binary signal.&nbsp; But, we could model it more like the other signals/watches where it has different status values that can come in and you watch for it to be &quot;cleared&quot; or whatever.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref31" id="cmnt31">[ae]</a><span class="c1">In current Ledger system, where it cares about this difference is at settlement time. If it&#39;s a not reviewed payment, it&#39;ll settle and auto clear, but if it&#39;s a pending manual review signal the batch is not settleable if I remember correctly. So if we want to provide info to Payout system on this difference we still need to record CONCERN risk signal.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref32" id="cmnt32">[af]</a><span class="c1">Hmm, that&#39;s an interesting case.&nbsp; I wonder if we want to try to build that in to this auto-clearing system, or if that stays as part of the payout system.&nbsp; If the concern signal causes the whole batch to be held, then it&#39;s probably a signal that should be directly consumed by the payouts system.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref33" id="cmnt33">[ag]</a><span class="c1">This is def a smart design! It keeps the decision to PB while taking care when current hold state is already meeting the request.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref34" id="cmnt34">[ah]</a><span class="c1">Thanks!&nbsp; Yeah, I went round and round on the design a few times trying to balance everything.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref35" id="cmnt35">[ai]</a><span class="c1">I think I may get the idea but could you elaborate this case here?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref36" id="cmnt36">[aj]</a><span class="c1">Basically that &quot;currently_is_frozen&quot; input (for example) is only used if we don&#39;t have signal data for the freeze status of that seller.&nbsp; So, it&#39;s like the default if the signal is missing.&nbsp; But, if the signal is missing we don&#39;t add the signal from the default, we just use that default whenever we evaluate the trigger.&nbsp; We only create a signal in the store when we get an actual signal passed in.&nbsp; My reasoning for this is that I don&#39;t want to create a bunch of &quot;seller isn&#39;t frozen&quot; signals for every seller who pays an app fee.&nbsp; We only need to create the freeze signal for the small number of sellers that actually get frozen.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref37" id="cmnt37">[ak]</a><span class="c1">I may need an example to clarify details- Say payment clearing system created a transaction&nbsp;that watched for all three signals(risk clear, not payment&nbsp;hold, not seller freeze). Currently we don&#39;t have risk signal arrived but we don&#39;t see freeze/hold on this merchant, so we send a transaction that watch for all. Meanwhile, what&#39;s in the `SellerFreezeSignalWatch.currently_is_frozen` field? Is it null or false?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref38" id="cmnt38">[al]</a><span class="c1">so, the current payment hold and seller freeze status of &quot;false&quot; would be sent as the &quot;currently_is_frozen&quot; and &quot;currently_is_held&quot; data.&nbsp; It&#39;s saying that those variables currently have the value of &quot;false&quot;.&nbsp; And, there would be no mention of those variables in the signal store.&nbsp; When the risk clear signal comes along, that will trigger the re-evaluation of the watches.&nbsp; The trigger processor will check the signal store again for the hold and freeze signals, and if no value is found, then the &quot;current&quot; value recorded in the watch will be assumed to still be accurate.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref39" id="cmnt39">[am]</a><span class="c1">Got it. Thanks for the explanation!</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref40" id="cmnt40">[an]</a><span class="c1">Why hold and freeze check are only on credit to developer, but not the debit from merchant transaction? Is it just because we&#39;ve seen history of fraudulent transactions from bad developer accounts?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref41" id="cmnt41">[ao]</a><span class="c1">It&#39;s because I want to make sure that the money actually leaves the seller balance.&nbsp; There is a reasonable alternative here where we have both the seller debit and the developer credit pending and they both post on the same trigger conditions.&nbsp; The product behavior would be a little different, so we could work that out with product when we come to the actual implementation.&nbsp; For now, I&#39;m just sketching out one possible&nbsp;way of using the system.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref42" id="cmnt42">[ap]</a><span class="c1">&#x1f44d;</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref43" id="cmnt43">[aq]</a><span class="c1">is this a problem?&nbsp; This will happen on every capture pretty much.&nbsp; Though, I suppose there&#39;s other data we have to store there for now so that it can get pulled out when the risk signal comes in.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref44" id="cmnt44">[ar]</a><span class="c1">Will there be in-place modifications on these trigger info? Will there be concurrency issues where multiple modifications try to write/update a transaction?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref45" id="cmnt45">[as]</a><span class="c1">no, the trigger data on the transaction is never modified</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref46" id="cmnt46">[at]</a><span class="c1">I was wondering more about the storage cost, but I guess actually it isn&#39;t too big a deal.&nbsp; We currently store data to use when risk posts anyhow.</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref47" id="cmnt47">[au]</a><span class="c1">Is the client always the payment clearing system (Ledger)?</span></p></div><div class="c10"><p class="c3"><a href="#cmnt_ref48" id="cmnt48">[av]</a><span class="c1">Follow up with Risk clear issues.&nbsp; Do we ever need this for something after the capture?&nbsp; We can&#39;t really read that model, but the capture processing and the risk signal are both triggered by the esperanto feed, so we&#39;re guaranteed they&#39;ll be close together.</span></p></div></body></html>
